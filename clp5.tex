\clearpage

\section{A SICStus \clpfd könyvtára}

A következõ fejezetben a SICStus \clpfd könyvtárával fogunk foglalkozni.
A \clpfd könyvtárat az alábbi módon lehet használatba venni:
\begin{verbatim}
:- use_module(library(clpfd)).
\end{verbatim}

\subsection{A \clpfd könyvtár általános jellemzése}

A \clpfd könyvtár az egész számok véges tartományain (\emph{finite domain, FD})
alapuló CLP rendszert valósít meg. A könyvtár általános alapelve, hogy a
CLP relációkat a \cd{\#} jellel kell kezdeni, ezzel különböztetve meg õket
a hagyományos Prolog jelektõl.

\enum{Felhasználható függvények}{
\item kétargumentumúak: {\tt +, -, *, /, mod, min, max}
\item egyargumentumú: {\tt abs} \\
Ezek a hagyományos matematikai mûveletekkel megegyezõ funkcióval rendelkeznek.
}
\enum{Felhasználható relációk}{
\item aritmetikaiak: \cd{\#<, \#>, \#=<, \#>=, \#= \#\bs=}\\
Ezek a jól ismert Prolog relációjelek megfelelõi, mindegyik \cd{xfx 700}
típusú operátor.
\item halmazmûveletek:
\begin{itemize}
  \item \cd{\var{X} in \var{Halmaz}} ---
     \cd{\var{X}} értékét \cd{\var{Halmaz}}-ból veszi
  \item \cd{domain([\var{Változók},\ldots], \var{Min}, \var{Max})} ---
     \cd{\var{Változók}} minden változója értékét a
     \cd{\var{Min}}..\cd{\var{Max}} intervallumból veszi
\end{itemize}
ahol \cd{\var{Halmaz}} lehet:
\begin{itemize}
\item felsorolás: \cd{\{\var{Szám},\ldots\}}
\item intervallum: \cd{\var{Min}..\var{Max}} (\cd{xfx 550} operátor)
\item két halmaz metszete: \cd{\var{Halmaz} \cd{/\bs} \var{Halmaz}}
    (\cd{yfx 500} beépített operátor)
\item két halmaz uniója: \cd{\var{Halmaz} \cd{\bs/} \var{Halmaz}}
    (\cd{yfx 500} beépített operátor)
\item egy másik halmaz komplemense: \cd{\bs\var{Halmaz}}
    (\cd{fy 500} operátor)
\end{itemize}
}

\cd{\var{Min}}-re megengedett az \cd{inf} névkonstans, ami az alsó korlát
hiányát jelenti ($-\infty$), hasonlóan \cd{\var{Max}}-ra megengedett a \cd{sup}
névkonstans, ami pedig a felsõ korlát hiányát jelenti ($+\infty$). A végtelen
korlátok általában csak kényelmi célokat használnak abban az esetben, ha
a tényleges korlátok kikövetkeztethetõek. Effektíven végtelen korlátokkal
rendelkezõ változóknak nem sok értelmük van, mert azok a címkézés (ld. késõbb)
során végtelen választási pontot hoznának létre (éppen ezért nem lehet olyan
változókat címkézni, amelyek végtelen tartománnyal rendelkeznek).
\br
A \clpfd világban egyszerû korlátoknak csak az \cd{\var{X} $\in$ \var{Halmaz}}
jellegû korlátokat tekintjük, minden más összetett korlátnak számít, éppen
ezért nagyon nagy hangsúly van az összetett korlátok erõsítõ tevékenységén
(ellentétben a \Clpb -vel, ahol nem is voltak összetett korlátok). Ez a tény
(illetve a \clpfd ,,lustasága'') teszi lehetõvé azt, hogy nagyobb problémákat
is megoldjunk vele. Az összetett korlátok erõsítõ tevékenysége a mesterséges
intelligencia-kutatások CSP (Constraint Satisfactory Problems) ágának
módszerein alapul.

Egy egyszerû \clpfd példa:

\begin{verbatim}
| ?- X in (10..20)/\ (\{15}), Y in 6..sup, Z #= X+Y.
X in(10..14)\/(16..20), Y in 6..sup, Z in 16..sup ? 
\end{verbatim}
\begin{verbatim}
| ?- X in 10..20, X #\= 15, Y in {2}, Z #= X*Y.
   Y = 2, X in(10..14)\/(16..20), Z in 20..40 ? 
\end{verbatim}

A második példán lustaságon kaphatjuk rajta a \clpfd következtetõ mechanizmust:
ugyan kikövetkeztethetõ lenne, hogy \cd{Z} csak 20 és 40 közötti \emph{páros}
szám lehet (mivel \cd{Y} páros, és \cd{X} 10 és 20 között van), sõt még
az is, hogy \cd{Z} semmiképp nem lehet 30 (mert \cd{X} sem lehet 15),
de ezt a \clpfd nem teszi meg, helyette egyszerûen megnézi \cd{X} alsó és
felsõ határát (10 és 20), ezeket beszorozza \cd{Y} alsó és felsõ határával
(ez jelen esetben azonos: 2 és 2), majd az így kapott négy szám minimuma és
maximuma által megadott intervallumra szûkíti \cd{Z}-t. Ezt a mechanizmust
\emph{intervallum-szûkítés}nek nevezzük, és az \ref{szukites} fejezetben
részletesen foglalkozunk majd vele.

\subsection{A \clpfd feladatok megoldási struktúrája}

Minden \clpfd feladat megoldása hasonló struktúrájú programot eredményez,
ezért érdemes megkülönböztetnünk a megoldási folyamat fõ lépéseit:

\begin{enumerate}
\item {\bf A probléma leképezése a \clpfd világra} \\
    Ebben a lépésben a problémának egy olyan modelljét kell megalkotnunk,
    amelyben a probléma egyes elemeit \clpfd fogalmakra (változókra,
    értéktartományokra) képezzük le.

\item {\bf Változók és korlátok felvétele} \\
    Ebben a lépésben be kell vezetnünk a feladatban szereplõ változókat,
    és fel kell vennünk a változók között fennálló korlát-relációkat.

\item {\bf Címkézés} \\
    Ha a problémának a korlátok alapján nincs egyértelmû megoldása, vagy
    ezt a rendszer nem tudta kikövetkeztetni, akkor a változókat el kell
    kezdenünk szisztematikusan az értéktartományaik egy-egy lehetséges
    értékéhez kötni, így meg fogjuk kapni a probléma összes megoldását.
    A címkézési folyamat a \clpb könyvtárnál látotthoz hasonló módon
    mûködik, de itt egy változó nem csak kétfajta értéket vehet fel.
    Ha a problémának a korlátok felvétele után már egyértelmû a megoldása,
    akkor a címkézési fázis elmarad.
\end{enumerate}

Lássuk a fent elmondottakat egy konkrét példán! A feladat az alábbi térkép
kiszínezése kék, piros és sárga színekkel úgy, hogy a szomszédos országok
különbözõ színûek legyenek, és ha két ország határán a \cd{<} jel van, akkor
a két szín ábécé-rendben a megadott módon kövesse egymást.

\begin{center}\epsfig{file=terkep.eps,width=0.2\textwidth}\end{center}

Egy lehetséges megoldási folyamat (\emph{zárójelben a CSP elnevezések}):

\begin{enumerate}
\item Minden mezõben elhelyezzük a három lehetséges színt ({\em változók és
tartományaik felvétele}).
\item Az ,,A'' mezõ nem lehet kék, mert annál ,,B'' nem lehetne kisebb.
A ,,B'' nem lehet sárga, mert annál ,,A'' nem lehetne nagyobb. Az ,,E'' és
,,D'' mezõk hasonlóan szûkíthetõk ({\em szûkítés, él-konzisztencia biztosítása}).
\item Ha az ,,A'' mezõ piros lenne, akkor mind ,,B'', mind ,,D'' kék lenne,
ami ellentmondás ({\em globális korlát, ill.\ borotválási technika}).
Tehát ,,A'' sárga. Emiatt a vele szomszédos ,,C'' és ,,E'' nem lehet sárga
({\em él-konszitens szûkítés}).
\item ,,C'' és ,,D'' nem lehet piros, tehát kék, így ,,B'' csak piros
lehet ({\em él-konszitens szûkítés}). Tehát az egyetlen megoldás:\\
A~=~sárga, B~=~piros, C~=~kék, D~=~kék, E~=~piros.
\end{enumerate}

Az alábbi ábrasorozaton láthatóak az egyes lépésekhez tartozó állapotok:

\btab{cccc}
\epsfig{file=terkep2.eps,width=0.18\textwidth} &
\epsfig{file=terkep3.eps,width=0.18\textwidth} &
\epsfig{file=terkep4.eps,width=0.18\textwidth} &
\epsfig{file=terkep5.eps,width=0.18\textwidth} \\
1. lépés & 2. lépés & 3. lépés & 4. lépés
\etab

\subsection{A CSP problémakör áttekintése}
\label{cspfogalmak}

Mint említettük, a \clpfd könyvtár a mesterséges intelligencia CSP megoldási
módszerein alapul, ezért mielõtt továbbmennénk, érdemes áttekinteni a CSP
problémakör fogalmait és eredményeit.

\enum{A CSP fogalma}{
\item Egy CSP-t egy $(X,D,C)$ hármassal jellemezhetünk, ahol
  \begin{itemize}
  \item $X = \tuple{x_1,\dots,x_n}$~--- változók
  \item $D = \tuple{D_1,\dots,D_n}$~--- tartományok, azaz nem üres halmazok
  \item $x_i$ változó a $D_i$ véges halmazból ($x_i$ tartománya) vehet fel
  értéket ($\forall i$-re $x_i \in D_i$)
  \item $C$ a problémában szereplõ korlátok (atomi relációk) halmaza,
  argumentumaik $X$ változói (például $C \ni c = r(x_1,x_3)$, $r \subseteq D_1 \times
  D_3$)
  \end{itemize}
\item A CSP feladat megoldása: minden $x_i$ változóhoz egy  $v_i\in D_i$
  értéket kell rendelni úgy, hogy minden $c\in C$ korlátot egyidejûleg
  kielégítsünk.
}

\definicio egy $c$ korlát egy $x_i$ változójának $d_i$ értéke
  \emph{felesleges}, ha nincs a $c$ többi változójának olyan értékrendszere,
  amely $x_i=d_i$-vel együtt kielégíti $c$-t.
\br
\tetel felesleges érték elhagyásával (szûkítés) ekvivalens CSP-t kapunk.
\br
\definicio egy korlát \emph{élkonzisztens} (\emph{arc consistent}),
  ha egyik változójának tartományában sincs felesleges érték. A CSP
  \emph{élkonzisztens}, ha minden korlátja élkonzisztens. Az élkonzisztencia 
  szûkítéssel biztosítható.
\br
Az \emph{élkonzisztencia} elnevezés onnan ered, hogy ha minden reláció
bináris, akkor a CSP probléma egy gráffal ábrázolható, ahol minden változónak
egy csomópont, minden relációnak egy él felel meg.

\enum{A CSP megoldás folyamata}{
\item felvesszük a változók tartományait;
\item felvesszük a korlátokat mint démonokat, amelyek szûkítéssel
él-konzisztenciát biztosítanak;
\item többértelmûség esetén címkézést (labeling) végzünk:
\begin{itemize}
\item kiválasztunk egy változót (pl.a legkisebb tartományút),
\item a tartományt két vagy több részre osztjuk (választási pont),
\item az egyes választásokat visszalépéses kereséssel bejárjuk
(egy tartomány üresre szûkülése váltja ki a visszalépést).
\end{itemize}
}

A térképszínezés, mint CSP feladat esetén minden országhoz egy változót
rendeltünk hozzá, ennek a változónak az értéke fogja az ország színét
kódolni. A színekhez ábécésorrend szerint az 1, 2, 3 értékek valamelyikét
rendeltük hozzá (kék $\to$ 1, piros $\to$ 2, sárga $\to$ 3), majd felvettük a
korlátokat egyrészt arra, hogy a szomszédos országok színei különböznek (ez a
változóértékek világában egy $\neq$ típusú relációt jelent), másrészt arra, hogy
az országok színei között megadott < relációk is teljesüljenek. Ezzel
kaptunk egy kiinduló korlát-gráfot, amit a felesleges élek elhagyásával
szûkítettünk. Az alábbi ábrán látható a kiinduló korlát-gráf és annak
élkonzisztens szûkített változata:

\btab{cp{5em}c}\epsfig{file=korlatok.eps,width=0.25\textwidth} & &
\epsfig{file=korlatok_elk.eps,width=0.25\textwidth}\etab

A CSP sémának a CLP világba történõ beágyazásával kapjuk a SICStusban lévõ
\clpfd könyvtárat. Minden CSP változónak egy \clpfd változó feleltethetõ meg,
a CSP változók értéktartományainak pedig egy-egy \clpfd egyszerû korlát.
A többi CSP korlát összetett \clpfd korlátként jelenik meg. A \clpfd korlát-tár
új változótartomány felvételén vagy egy meglévõ változó tartományának
szûkítésén módosulhat. Az összetett korlátok \emph{démon}ok lesznek, amelyek
hatásukat az \emph{erõsítés}en keresztül fejtik ki (ld. \ref{erosit} fejezet).
Az erõsítés mindig egyszerû korlátokat ad a korlát-tárhoz. A démonok ciklikusan
mûködnek: megszületnek, szûkítenek, elalszanak, aktiválódnak, szûkítenek,
elalszanak, \ldots aktiválódnak, szûkítenek, és amikor már levezethetõek a
korlát-tár tartalmából, akkor megszûnnek létezni. A démonokat mindig az
érintett korlátbeli változók tartományának módosulása aktiválja. A szûkítés
mértéke a démontól függ, néha nem elõnyös az összes lehetséges szûkítést
elvégezni, mert túlságosan költséges lenne.

\subsection{A \clpfd könyvtár jellegzetességei}

Ebben az alfejezetben a \clpfd könyvtár néhány jellegzetességét mutatjuk be
példákon keresztül. A példák megértéséhez egyetlen, nagyon fontos állítást
kell szem elõtt tartanunk: {\bf a \clpfd démonok csak a korlát-táron keresztül
hatnak egymásra!}
\br
A fenti mondat azt takarja, hogy a démonok nem ,,látják'' egymást, az
egymással való interakciójukat kizárólag a korlát-táron keresztül
végzik: az egyik démon szûkíti a korlát-tárat, ennek hatására egy
másik démon felébred, szûkít, erre egy harmadik démon ébred fel
és így tovább... Elõfordulhatnak azonban olyan esetek, amikor egyik
démon sem tud felébredni, és így esetleg egy nyilvánvaló ellentmondást
nem vesz észre a rendszer, mint például a következõ példában:

\begin{verbatim}
| ?- domain([X,Y,Z], 1, 2), X #\= Y, X #\= Z, Y #\= Z.
X in 1..2,
Y in 1..2,
Z in 1..2 ? ;
no
\end{verbatim}

Mivel \cd{X}, \cd{Y} és \cd{Z} értékkészlete is az 1 és a 2 számokból
áll, és az \cd{X \#\bs= Y} jellegû korlátok démonai csak akkor ébrednek fel, ha
valamelyik változójuk behelyettesített lesz, ezért egyik démon sem tud szûkíteni,
és az ellentmondás nem derül ki. A megoldást globális korlátok (pl. az
\cd{all_distinct/1}) használata jelenti majd. A globális korlátok olyan korlátok,
amelyek mûködésükkel több korlát hatását fogják össze egyetlen démonban, így
ez a démon rá tud jönni az ilyen jellegû ellentmondásokra. Ezekrõl a korlátokról
a késõbbiekben még részletesen lesz szó (ld. \ref{globalis}. fejezet).

Hasonló szituációt jelent a következõ példa is:

\begin{verbatim}
| ?- X #> Y, Y #> X.
Y in inf..sup,
X in inf..sup ? ;
no
\end{verbatim}

Ha ugyanezt a két korlátot úgy vesszük fel, hogy közben \cd{X} és \cd{Y} tartományát
végesre szûkítjük, akkor már nem jelentkezik a probléma:

\begin{verbatim}
| ?- domain([X,Y], 1, 10), X #> Y, Y #> X.
no
\end{verbatim}

Azonban ha a tartományt egy picit tágabbra vesszük, újabb problémával találjuk
szembe magunkat, a meglepõen nagy futási idõvel:

\begin{verbatim}
| ?- statistics(runtime,_),
     ( domain([X,Y], 1, 100000), X #> Y, Y #> X
     ; statistics(runtime,[_,T])
     ).
T = 3630 ? ;
no
\end{verbatim}

Ennek oka ismét abban keresendõ, hogy a démonok csak a korlát-táron keresztül
hatnak egymásra. Nézzük meg ugyanis ennek a példának a futását az \fdbg
nyomkövetõ könyvtár használatával, 10-es tartományhatárra (az \fdbg könyvtárról
bõvebben a \ref{fdbg}. fejezetben lesz szó)!

\begin{verbatim}
| ?- use_module(library(fdbg)).
| ?- fdbg_on, fdbg_assign_name(X, x), fdbg_assign_name(Y, y),
     domain([X,Y], 1, 10), X #> Y, Y #> X.

domain([<x>,<y>], ==> x = inf..sup -> 1..10,     
       1,10)          y = inf..sup -> 1..10
                      Constraint exited.
                  
<x> #>= <y>+1     ==> x = 1..10 -> 2..10,   y = 1..10 -> 1..9
                                            
<x>+1 #=< <y>     ==> x = 2..10 -> 2..8,    y = 1..9 -> 3..9
                                            
<x> #>= <y>+1     ==> x = 2..8 -> 4..8,     y = 3..9 -> 3..7
                                            
<x>+1 #=< <y>     ==> x = 4..8 -> 4..6,     y = 3..7 -> 5..7
                                            
<x> #>= <y>+1     ==> x = 4..6 -> {6},      y = 5..7 -> {5} 
                      Constraint exited.
                  
2 #=< 0           ==> Constraint failed.
% Valójában a korlát <x>+1 #=< <y>, azaz 6+1 #=< 5
no
\end{verbatim}

A kimenetet értelmezve láthatjuk, hogy az \cd{X} és az \cd{Y} változók
tartománya nagyon lassan szûkül: kezdetben az \cd{X in 1..10} feltétel
és az \cd{X \#> Y} (a \clpfd belsõ ábrázolása szerint \cd{X \#>= Y+1})
korlát démona miatt \cd{X} tartománya a \cd{2..10} halmazra, \cd{Y}-é pedig
az \cd{1..9}-re szûkül. Ekkor a tartománymódosulások hatására felébred
az \cd{Y \#> X} korlát démona is, és szûkíti \cd{X}-et a \cd{2..8}, \cd{Y}-t
a \cd{3..9} halmazra. Ettõl viszont újból felébred az \cd{X \#> Y} korlát
démona, és így folytatódik a dolog egészen addig, amíg végül az egyik
démon észre nem veszi, hogy itt meghiúsulás fog következni. Nagyobb
tartományhatárok esetén ez a láncreakció értelemszerûen tovább tart, sõt,
mint láttuk, végtelen tartományhatárok esetén nem is indul el.

\subsection{Egyszerû constraint feladatok megoldása}

\subsubsection{Térképszínezés}

Emlékeztetõül a feladat: színezzük ki az alábbi térképet kék, piros és
sárga színekkel úgy, hogy a szomszédos országok különbözõ színûek legyenek,
és ha két ország határán a \cd{<} jel van, akkor a két szín ábécé-rendben
a megadott módon kövesse egymást.

\begin{center}\epsfig{file=terkep.eps,width=0.2\textwidth}\end{center}

Elõször írjuk fel a megfelelõ korlátokat leíró \clpfd célsorozatot:

\begin{alltt}
| ?- use_module(library(clpfd)).
...
| ?- domain([A,B,C,D,E], 1, 3), 
     A #> B, A #\bs= C, A #\bs= D, A #\bs= E,
     B #\bs= C, B #\bs= D, C #\bs= E, D #< E.
A in 2..3, B in 1..2, C in 1..3, D in 1..2, E in 2..3 ? ;
no
\end{alltt}

Látható, hogy a Prolog az élkonzisztencia biztosítását elvégezte, de a
megoldást még nem tudta kikövetkeztetni. A megoldások meghatározásához
meg kell kérni a rendszert, hogy az \cd{A} változót rendre helyettesítse
be az 1, 2, 3 értékekre. Ez többféleképpen is elvégezhetõ: egyrészt a
hagyományos \cd{member/2} eljárással, amelynél azonban egyesével fel kell
sorolnunk \cd{A} lehetséges értékeit, ami nagy értékkészletnél kényelmetlen
lehet:

\begin{alltt}
| ?- domain([A,B,C,D,E], 1, 3), 
     A #> B, A #\bs= C, A #\bs= D, A #\bs= E,
     B #\bs= C, B #\bs= D, C #\bs= E, D #< E,
     member(A, [1,2,3]).
A = 3, B = 2, C = 1, D = 1, E = 2 ?
\end{alltt}

Az ilyen problémák megoldására szolgál az \cd{indomain/1} eljárás, amely
ezt a behelyettesítést automatikusan elvégzi a paraméterként adott változóra:

\begin{alltt}
| ?- domain([A,B,C,D,E], 1, 3), \ldots, indomain(A).
A = 3, B = 2, C = 1, D = 1, E = 2 ?
\end{alltt}

Elõfordulhatott volna azonban, hogy \cd{A} behelyettesítése még mindig
nem elég ahhoz, hogy kiderüljön az összes megoldás, ezért célszerû
a behelyettesítést mind az 5 változóra elvégezni. Ezt a \cd{labeling/2}
eljárás végzi, amely elsõ paramétere egy opciólista, amely a címkézés
menetét szabályozza (ezzel majd késõbb foglalkozunk), második paramétere
pedig egy változólista, amelyre a címkézést el akarjuk végezni.

\begin{alltt}
| ?- domain([A,B,C,D,E], 1, 3), \ldots, labeling([],[A,B,C,D,E]).
A = 3, B = 2, C = 1, D = 1, E = 2 ?
\end{alltt}

Annak megfogalmazására, hogy az \cd{A}, \cd{C} és \cd{E} változók értéke
mind különbözik, a Prolog kínál egy egyszerûbb és hatékonyabb megoldást is,
az \cd{all_distinct/1} predikátumot. Ez egy listát vár paraméterként, és
ügyel arra, hogy a lista összes eleme különbözõ értékeket vegyen fel.

\begin{alltt}
| ?- domain([A,B,C,D,E], 1, 3),
     A #> B, A #\bs= E, B #\bs= C, B #\bs= D, D #< E,
     all_distinct([A,C,E]). 
A = 3, B = 2, C = 1, D = 1, E = 2 ? ; no
\end{alltt}

Látható, hogy itt már címkézésre se volt szükség, mivel az \cd{all_distinct}
korlát ,,erõsebb'' a páronkénti különbözõségnél.

\subsubsection{Kódaritmetika (SEND+MORE=MONEY)}

\label{sendmoremoney}

A feladvány: írjon a betûk helyébe tízes számrendszerbeli számjegyeket
(azonosak helyébe azonosakat, különbözõek helyébe különbözõeket) úgy, hogy a
SEND+MORE=MONEY egyenlõség igaz legyen. Szám elején nem lehet 0 számjegy.

\begin{verbatim}
send(SEND, MORE, MONEY) :-
  length(List, 8),
  domain(List, 0, 9),               % tartományok 
  send(List, SEND, MORE, MONEY),    % korlátok
  labeling([], List).               % címkézés
\end{verbatim}
\begin{verbatim}
send(List, SEND, MORE, MONEY) :-
  List=[S,E,N,D,M,O,R,Y], 
  alldiff(List), S #\= 0, M #\= 0,
  SEND #=  1000*S+100*E+10*N+D,
  MORE #= 1000*M+100*O+10*R+E,
  MONEY #= 10000*M+1000*O+100*N+10*E+Y,
  SEND+MORE #= MONEY.
\end{verbatim}
\begin{alltt}
% alldiff(L): L elemei mind különbözõek (buta megvalósítás).
% Lényegében azonos a beépített all_different/1 kombinatorikai globális korláttal.
alldiff([]).
alldiff([X|Xs]) :- outof(X, Xs), alldiff(Xs).
\end{alltt}
\begin{verbatim}
outof(_, []).
outof(X, [Y|Ys]) :- X #\= Y, outof(X, Ys).
\end{verbatim}

A fenti programon jól látszik a szokásos \clpfd struktúra (tartományok
felvétele, korlátok felvétele, címkézés). Az ,,azonos betûk azonos számokat,
különbözõ betûk különbözõ számokat jelentenek'' kitételt egy saját
\cd{alldiff/1} predikátummal valósítjuk meg, amely lényegében megegyezik
az \cd{all_different/1} beépített globális korláttal. Fontos megjegyezni,
hogy az \cd{all_different/1} és az \cd{all_distinct/1} korlátok \emph{nem}
ekvivalensek, az elõbbi csak páronkénti különbözõséget valósít meg! Gyakran
azonban ez is elég, és az \cd{all_different} emellett gyorsabb futást biztosít,
tehát néha érdemes használni. Ezen magyarázat után lássuk a program futását:

\begin{verbatim}
| ?- send(SEND, MORE, MONEY).
MORE = 1085, SEND = 9567, MONEY = 10652 ? ;
no
\end{verbatim}

Nézzük meg azt is, hogy mit adna ki a program, ha elhagynánk a címkézést:

\begin{verbatim}
| ?- List=[S,E,N,D,M,O,R,Y], domain(List, 0, 9), 
     send(List, SEND, MORE, MONEY).
        List = [9,E,N,D,1,0,R,Y],
        SEND in 9222..9866,
        MORE in 1022..1088,
        MONEY in 10244..10888,
        E in 2..8, N in 2..8, D in 2..8, 
        R in 2..8, Y in 2..8 ? ; no
\end{verbatim}

Amint látható, a rendszer helybõl rájött arra, hogy mivel az eredmény öt
számjegybõl áll, a két összeadandó viszont csak négybõl, ezért \cd{M}
csak 1 lehet. Ha viszont \cd{M} 1, akkor \cd{S}-nek 9-nek kell lennie,
különben nem keletkezhet átvitel, ilyenkor viszont \cd{O} csak nulla lehet.
A többi változó értéke csak a címkézés után derül ki.

\subsubsection{A zebra feladat}
Szintén egy \Clpfd -ben könnyen megfogható feladat: adott 5 különbözõ
nemzetiségû ember, 5 különbözõ színû ház, 5 különbözõ foglalkozás, 5
különbözõ állat és 5 különbözõ ital. Egy embernek pontosan egy
foglalkozása, nemzetisége, háza, kedvenc itala és állata van. A
feladat az, hogy az ismert kötöttségek alapján megmondjuk, hogy melyik
nemzetiségû ember kedvenc állata a zebra. Az embereket megsorszámozzuk
1-tõl 5-ig, majd minden egyes foglalkozáshoz, nemzetiséghez, házhoz,
italhoz és állathoz egy constraint változót rendelünk, amely értékét
az 1..5 halmazból veszi fel. Egy ilyen változó $i$ értéke azt jelenti,
hogy az általa reprezentált tulajdonság az $i$. számú emberhez
tartozik. A kötöttségeket ez alapján könnyen felírhatjuk, például az,
hogy a diplomata háza a sárga, egyszerûen a két megfelelõ
constraint-változó egyenlõvé tételével biztosítható.  A kötöttségek a
programból könnyen kideríthetõk, itt nem soroljuk fel õket. Az
egyetlen figyelmet érdemlõ feltétel annak a megvalósítása, hogy
valaki egy adott ház szomszédjában lakik. Ezt a \cd{nextto/2} predikátum
kezeli. A \cd{nextto/2} tulajdonképpen egy vagylagos szerkezet, amit a
Prolog választási pontokkal valósít meg - vagyis spekulatív módon veszi fel a
vagy-kapcsolatban szereplõ korlátokat, és minden lehetõségre
megpróbálja megoldani az aktuális korlát rendszert. Ez nem a legszerencsésebb
megoldás, mivel sok választási pont esetén rengeteg idõt igényelhet. A
vagylagos szerkezetekrõl a \clpfd esettanulmányokban (\pageref{diszjunkcio}.
oldal) még lesz szó. Adott esetben a 

\begin{verbatim}
nextto(A,B):- abs(A-B) #= 1.
\end{verbatim}

megoldás sokkal szerencsésebb lenne, mivel ez nem generál választási
pontokat.

\begin{verbatim}
:- use_module(library(lists)).
:- use_module(library(clpfd)).

zebra(ZOwner, All):-
  All = [England,Spain,Japan,Norway,Italy,
         Green,Red,Yellow,Blue,White,
         Painter,Diplomat,Violinist,Doctor,Sculptor,
         Dog,Zebra,Fox,Snail,Horse,
         Juice,Water,Tea,Coffee,Milk],
  domain(All, 1, 5),
  alldiff([England,Spain,Japan,Norway,Italy]),
  alldiff([Green,Red,Yellow,Blue,White]),
  alldiff([Painter,Diplomat,Violinist,Doctor,Sculptor]),
  alldiff([Dog,Zebra,Fox,Snail,Horse]),
  alldiff([Juice,Water,Tea,Coffee,Milk]),
  England = Red,          Spain = Dog,
  Japan = Painter,        Italy = Tea,
  Norway = 1,             Green = Coffee,
  Green #= White+1,       Sculptor = Snail,
  Diplomat = Yellow,      Milk = 3,
  Violinist = Juice,      nextto(Norway, Blue),
  nextto(Fox, Doctor),    nextto(Horse, Diplomat),
  labeling([ff], All),
  nth(N, [England,Spain,Japan,Norway,Italy], Zebra),
  nth(N, [england,spain,japan,norway,italy], ZOwner).

nextto(A, B) :-  A #= B+1.
nextto(A, B) :-  A #= B-1.
\end{verbatim}

\subsubsection{N királynõ a sakktáblán}

A feladat elhelyezni egy $n * n$-es sakktáblán $n$ királynõt úgy, hogy
egyik se üsse a másikat.
\br
A megoldás minden királynõt külön oszlopba tesz, majd mindegyikükhöz
egy változót rendel, ami a királynõ oszlopbeli pozícióját adja meg. A
változók tartományának deklarálása után minden két királynõ között
felállít egy constraint-et (\cd{no\_threat/3}), ami azt adja meg, hogy
a két királynõ nem üti egymást. Ehhez meg kell adni a két királynõ
oszlopainak távolságát, ami itt az \cd{I} paraméter. Ezek után a
program végrehajtja a címkézést first-fail heurisztikával. A first-fail
elv mindig a legkisebb értékkészlettel rendelkezõ változót helyettesíti
be elõször, abban reménykedve, hogy így hamarabb kiderülnek a hibás ágak.
A címkézési módokról késõbb lesz szó.

\label{no:threat}

\begin{verbatim}
:- use_module(library(clpfd)).

% A Qs lista N királynõ biztonságos elhelyezését
% mutatja egy N*N-es sakktáblán. Ha a lista
% i. eleme j, akkor az i. királynõt az i. sor j.
% oszlopába kell helyezni.
queens(N, Qs):-
  length(Qs, N), domain(Qs, 1, N),
  safe(Qs),
  labeling([ff],Qs).  % first-fail elv

% safe(Qs): A Qs lista a királynõk biztonságos
% elhelyezését írja le.
safe([]).
safe([Q|Qs]):-
  no_attack(Qs, Q, 1),
  safe(Qs).

% no_attack(Qs, Q, I): A Qs lista által leírt
% királynõk egyike sem támadja a Q oszlopban levõ
% kiralynõt, feltéve hogy Q és Qs távolsága I.
no_attack([],_,_).
no_attack([X|Xs], Y, I):-
  no_threat(X, Y, I),
  J is I+1, no_attack(Xs, Y, J).

% Az X és Y oszlopokban  I sortávolságra levõ
% királynõk nem támadják egymást.
no_threat(X, Y, I) :-
  Y #= X, Y #= X-I, Y #= X+I.
\end{verbatim}



\subsection{Szûkítési szintek}
\label{szukites}

A könnyebb megértés érdekében elõször informálisan, egy egyszerû
kétargumentumú relációra fogjuk megfogalmazni az \emph{intervallum-szûkítés}
és a \emph{tartományszûkítés} fogalmát, utána pedig formalizáljuk a
leírtakat.
\br
Tekintsünk egy $r(X,Y)$ bináris relációt! Ekkor $r$ \emph{tartományszûkítése}
során $X$ tartományából elhagyjuk az összes olyan $x$ értéket, amelyhez nem
található $Y$ tartományában olyan $y$ érték, hogy $r(x,y)$ fennáll. Hasonlóan
szûkítjük $Y$ tartományát is. A folyamat eredménye az élkonzisztencia (lásd
a fogalom definícióját a \ref{cspfogalmak} fejezetben).
\emph{Intervallum-szûkítés} során viszont $X$ tartományából elhagyjuk annak
alsó vagy felsõ határát, ha ahhoz nem található olyan $y$ érték, amely $Y$
határai közé esik, és azzal az $r$ reláció fennáll. Hasonlóan szûkítjük
$Y$ tartományának határait is, és ezeket a lépéseket addig ismételjük,
amíg tudunk szûkíteni. Ez a módszer nem biztosít élkonzisztenciát, de
gyorsabban elvégezhetõ.
\br
Példa: legyen $x \in \{0,1,2,3,4,5\}$ és $y \in \{-1,1,3,4\}$, $r(x,y)$ pedig
az $x=|y|$ reláció. A tartományszûkítés $x$ értékkészletébõl elhagyja
a 0, 2, 5 értékeket, hiszen semelyik $y$ érték abszolútértéke nem lehet
sem 0, sem 2, sem 5. Az intervallum-szûkítés viszont elõször csak a 0
és az 5 kizárásával próbálkozik. 0-t nem zárhatja ki, hiszen $y$ tartományának
szélsõ értékei közé (tehát -1 és 4 közé) esik a 0, és $0=|0|$. 5-öt
kizárhatja, mert sem a -5, sem az 5 nem esik $y$ szélsõ értékei közé,
de a 4-et már nem zárhatja ki, ezért $x$ csak a $\{0,1,2,3,4\}$ halmazra
szûkül.
\br
A fenti példán jól látszik az intervallum-szûkítés két gyengesége:

\begin{enumerate}
\item csak a tartomány szélsõ értékeit hajlandó elhagyni, ezért nem hagyja el
a \cd{2} értéket;
\item a másik változó tartományában nem veszi figyelembe a ,,lyukakat'', így
a példában \cd{Y} tartománya helyett annak \emph{lefedõ intervallumát}, azaz
a \cd{-1..4} intervallumot tekinti, ezért nem hagyja el \cd{X}-bõl
a \cd{0} értéket.
\end{enumerate}

Ugyanakkor az intervallum-szûkítés általában konstans idejû mûvelet,
míg a tartományszûkítés ideje (és az eredmény mérete) erõsen függ a
tartományok méretétõl, ezért sok esetben a SICStus \clpfd könyvtár csak
az intervallum-szûkítést garantálja, a tartományszûkítést nem.
\br
Ezek után fogalmazzuk meg a definícióinkat formálisan is!

\enum{Jelölések}{
\item Legyen $C$ egy $n$-változós korlát, $s$ egy korlát-tár,
\item $D(X,s)$ az $X$ változó tartománya az $s$ tárban,
\item $D'(X,s) = {\rm min} D(X,s) .. {\rm max} D(X,s)$ az $X$ változó
      tartományát \emph{lefedõ} (legszûkebb) \emph{intervallum}.}

\enum{A szûkítési szintek definíciója}{
\item tartományszûkítés (domain consistency) \\
\definicio $C$ \emph{tartományszûkítõ}, ha minden szûkítési lépés lefutása után az
adott $C$ korlát él-konzisztens, azaz bármelyik $X_i$ változójához és annak
tetszõleges $V_i \in D(X_i,s)$ megengedett értékéhez található a többi
változónak olyan $V_j \in D(X_j,s)$ értéke ($j = 1, \ldots, i-1,i+1,\ldots, n$),
hogy $C(V_1, \ldots V_n)$ fennálljon. 
 
\item intervallum-szûkítés (interval consistency) \\
\definicio $C$ \emph{intervallum-szûkítõ} ha minden szûkítési lépés lefutása után igaz,
hogy $C$ bármelyik $X_i$ változója esetén e változó tartományának mindkét
{\em vég}pontjához (azaz a $V_i = {\rm min} D(X_i,s)$ illetve
$V_i = {\rm max} D(X_i,s)$ értékekhez) található a többi változónak
olyan $V_j \in D'(X_j,s)$ értéke ($j = 1, \ldots, i-1,i+1, \ldots, n$), hogy
$C(V_1, \ldots V_n)$ fennálljon.
}

A tartományszûkítés lokálisan (egy korlátra nézve) a lehetõ legjobb, de
nem garantálja a megoldást akkor sem, ha az összes korlát tartományszûkítõ,
mivel nem tudja figyelembe venni a többi korlát hatását. Ezt illusztrálja
a már bemutatott \cd{all_different $\longleftrightarrow$ all_distinct} probléma, ahol
kihasználjuk, hogy az \cd{all_different} ekvivalens a páronkénti különbözõségek
felvételével:

\begin{verbatim}
| ?- domain([X,Y,Z], 1, 2), X #\= Y, Y #\= Z, Z #\= X.
X in 1..2, Y in 1..2, Z in 1..2 ? ;
no
| ?- domain([X,Y,Z], 1, 2), all_distinct([X,Y,Z]).
no
\end{verbatim}

A SICStusban a halmazkorlátok (triviálisan) tartományszûkítõk. A
\emph{lineáris} aritmetikai korlátok legalább intervallum-szûkítõk,
a nemlineáris aritmetikai korlátokra nincs garantált szûkítési szint.
Ha a változók valamelyik határa végtelen (\cd{inf} vagy \cd{sup}), akkor
nincs garantált szûkítési szint, de az aritmetikai és a halmazkorlátok
ilyenkor is szûkítenek. A késõbb tárgyalt korlátokra egyenként megadjuk majd
a szûkítési szinteket.
\br
Néhány példa a szûkítési szintekre:
\begin{verbatim}
| ?- X in {4,9}, Y in {2,3}, Z #= X-Y. % intervallum-szûkítõ
X in {4}\/{9}, Y in 2..3, Z in 1..7 ? 
\end{verbatim}
\begin{verbatim}
| ?- X in {4,9}, Y in {2,3}, plus(Y, Z, X).
    % plus(A, B, C): A+B=C tartományszûkítõ módon
X in {4}\/{9}, Y in 2..3, Z in(1..2)\/(6..7) ? 
\end{verbatim}
\begin{verbatim}
| ?- X in {4,9}, Y in {2}, /* azaz Y=2 */, Z #= X-Y. % tartományszûkítõ
Y = 2, X in {4}\/{9}, Z in {2}\/{7} ? 
\end{verbatim}
\begin{verbatim}
| ?- X in {4,9}, Z #= X-Y, Y=2.
    % így csak intervallum-szûkítõ!
    % vö. fordítási idejû korlát-kifejtés
Y = 2, X in {4}\/{9}, Z in 2..7 ? 
\end{verbatim}
\begin{verbatim}
| ?-domain([X,Y], -10, 10), X*X+2*X+1 #= Y.
    % Ez nem intervallum-szûkítõ, Y<0 nem lehet!
X in -4..4, Y in -7..10 ? 
\end{verbatim}
\begin{verbatim}
| ?- domain([X,Y], -10, 10), (X+1)*(X+1) #= Y.
    % garantáltan nem, de intervallum-szûkítõ:
X in -4..2, Y in 0..9 ?   
\end{verbatim}



\subsection{Korlátok végrehajtása}

\label{korlatvegrehajtas}

Egy korlát végrehajtása több fázisból áll:

\begin{enumerate}
\item A korlát kifejtése belsõ, elemi korlátokra (ld. \ref{korlatkif}. fejezetben)
\item A korlát felvétele. Itt rögtön két lehetõség adódik:

	\begin{itemize}
	\item Egyszerû korlát (pl. \cd{X \#< 4}) esetén a korlát azonnal végrehajtásra kerül
	\item Összetett korlát esetén a korlátból démon képzõdik, a démon elvégzi a
	lehetséges szûkítéseit, meghatározza, hogy milyen feltételek esetén kell újra
	aktiválódnia, majd elalszik.
	\end{itemize}

\item Ha a korlátból démon képzõdött, és a démon ébresztési feltételei teljesülnek, akkor
aktiválódik, elvégzi a szûkítéseit, majd dönt a folytatásról. A döntés eredménye kétféle
lehet:

	\begin{itemize}
	\item Ha a démon már levezethetõ a tárból, akkor befejezi mûködését
	\item Ha a démon még nem vezethetõ le a tárból, akkor újból elalszik
	\end{itemize}

\end{enumerate}

Nézzük az eddig elmondottakat néhány konkrét példán!

\enumhead{\cd{A \#\bs= B} {\rm (tartományszûkítõ)}}
\begin{itemize}
\item {\bf Aktiválás feltétele:} ha \cd{A} vagy \cd{B} konkrét értéket kap
\item {\bf A szûkítés módja:} az adott értéket kizárja a másik változó értelmezési
tartományából
\item {\bf A folytatás menete:} mivel ilyenkor már a démon biztosan levezethetõ
a tárból, ezért a démon mûködése befejezõdik
\end{itemize}

\enumhead{\cd{A \#< B} {\rm (tartományszûkítõ)}}
\begin{itemize}
\item {\bf Aktiválás feltétele:} ha \cd{A} alsó határa (min(\cd{A})) vagy \cd{B}
felsõ határa (max(\cd{B})) változik
\item {\bf A szûkítés módja:} \cd{A} tartományából kihagyja az $X \ge$ max(\cd{B})
értékeket, \cd{B} tartományából pedig kihagyja az $Y \le$ min(\cd{A}) értékeket
\item {\bf A folytatás menete:} ha max(\cd{A}) $<$ min(\cd{B}), akkor lefut,
egyébként elalszik
\end{itemize}

\enumhead{\cd{all\_distinct([A$_1$,A$_2$,\ldots])} {\rm (tartományszûkítõ)}}
\begin{itemize}
\item {\bf Aktiválás feltétele}: ha bármelyik változó tartománya változik
\item {\bf A szûkítés módja}: páros gráfokban maximális párosítást keresõ
algoritmus segítségével minden olyan értéket elhagy, amelyek esetén a korlát nem
állhat fenn. Példa:
\begin{verbatim}
| ?- A in 2..3, B in 2..3, C in 1..3, 
     all_distinct([A,B,C]).
\end{verbatim}
\begin{verbatim}
                 C = 1, A in 2..3, B in 2..3 ? 
\end{verbatim}
\item {\bf A folytatás menete}: ha már csak egy nem-konstans argumentuma van,
akkor lefut, különben újra elalszik. Látszólag jobb döntésnek tûnhet, ha a korlát
akkor futna le, amikor a tartományok már mind diszjunktak, de a SICStus nem így
csinálja, valószínûleg azért, mert nem éri meg.
\end{itemize}

\enumhead{\cd{X+Y \#= T} {\rm (intervallum-szûkítõ)}}
\begin{itemize}
\item {\bf Aktiválás feltétele}: ha bármelyik változó alsó vagy felsõ határa változik (az
intervallum-szûkítés miatt nem minden tartományváltozásra ébred fel)
\item {\bf A szûkítés módja}: \cd{T}-t szûkíti a \cd{({\rm min} X+{\rm min} Y)..({\rm max}
X+{\rm max} Y)} intervallumra, \cd{X}-t szûkiti a \cd{({\rm min} T-{\rm max} 
Y)..({\rm max} T-{\rm min} Y)} intervallumra, \cd{Y}-t analóg módon szûkíti.
\item {\bf A folytatás menete}: ha (a szûkítés után) mindhárom változó konstans, akkor lefut,
különben újra elalszik.
\end{itemize}

Mivel a \clpfd alapvetõen ,,lusta'' mûködésû, és nem végez el minden lehetséges
szûkítést, ezért elõfordulhat, hogy ugyanazon változókra megfogalmazott, jelentéstartalomban
megegyezõ, de különbözõ szintaktikájú korlátok nem azonos mértékben szûkítenek,
mint ahogy azt a következõ példa is mutatja:

\begin{verbatim}
| ?- domain([X,Y], 0, 100), X+Y #=10, X-Y #=2.
                X in 2..10, Y in 0..8 ? 

| ?- domain([X,Y], 0, 100), X+Y #=10, X+2*Y #=14.
                X = 6, Y = 4 ? 
\end{verbatim}

Az alsó és a felsõ példának ugyanaz a megoldása, az elsõ esetben az \cd{X-Y \#= 2}
korlát intervallum-szûkítõ, és az intervallum-szûkítés a már fennálló \cd{X in 2..10}
és \cd{Y in 0..8} tartományokat nem tudja tovább szûkíteni. Az \cd{X+2*Y \#= 14}
korlát viszont ugyan garantáltan nem tartományszûkítõ, de itt mégis elvégzi a
tartományszûkítést, és ezzel megtalálja a megoldást.

\subsection{Korlátok tükrözése: \emph{reifikáció}}

\definicio egy $C$ korlát \emph{reifikáció}ja (\emph{tükrözés}e) a korlát
igazságértékének megjelenítése egy 0-1 értékû korlát változóban. Jelölése:
$C$ \cd{\#<=> B}. Ezt úgy kell értelmezni, hogy \cd{B} egy 0-1 értékû változó,
és \cd{B} akkor és csak akkor 1, ha $C$ igaz.
\br
{\bf Példa:} \cd{(X \#>= 3) \#<=> B} jelentése: \cd{B} az \cd{X $\ge$ 3} egyenlõtlenség
igazságértéke.
\br
Az eddig ismertetett halmaz- és aritmetikai korlátok (az úgynevezett \emph{formulakorlátok})
mind tükrözhetõek, de a globális korlátok (pl. \cd{all_different/1}, \cd{all_distinct/1})
nem. A \ref{fdpred}. fejezetben ismertetésre kerülõ FD predikátumok a
felhasználó határozza meg az FD predikátum klózainak megfelelõ kialakításával.
\br
Egy $C$ \cd{\#<=> B} korlát végrehajtása többféle szûkítést is igényel:

\begin{description}
\item a) amikor \cd{B}-rõl kiderül valami (azaz behelyettesítõdik): ha \cd{B=1},
fel kell venni ({\em post}) a korlátot, ha \cd{B=0}, fel kell venni a negáltját.
\item b) amikor $C$-rõl kiderül, hogy levezethetõ a tárból, végre kell hajtani
a \cd{B=1} helyettesítést
\item c) amikor $\lnot C$-rõl kiderül, hogy levezethetõ a tárból, végre kell
hajtani a \cd{B=0} helyettesítést
\end{description}

A fenti három fajta szûkítést három különbözõ démon végzi. A levezethetõségi vizsgálat
különbözõ ,,ambíciókkal'', különbözõ bonyolultsági szinteken végezhetõ el (bõvebben:
\ref{levezethetoseg}. fejezet).
\br
Lássuk a fent leírtakat mûködés közben!

\begin{itemize}
\item Alappélda, csak \cd{B} szûkül:
\begin{alltt}
| ?- X#>3 #<=> B.                  \(\Rightarrow\) B in 0..1
\end{alltt}
\item Ha \cd{B} értéket kap, akkor a rendszer felveszi a korlátot, illetve a negáltját:
\begin{alltt}
| ?- X#>3 #<=> B, B = 1.           \(\Rightarrow\) X in 4..sup
| ?- X#>3 #<=> B, B = 0.           \(\Rightarrow\) X in inf..3
\end{alltt}
\item Ha levezethetõ a korlát, vagy a negáltja, akkor \cd{B} értéket kap.
\begin{alltt}
| ?- X#>3 #<=> B, X in 15..sup.    \(\Rightarrow\) B = 1
| ?- X#>3 #<=> B, X in inf..0.     \(\Rightarrow\) B = 0
\end{alltt}
\item Ha a tár megengedi a korlát és a negáltja teljesülését is, akkor \cd{B} nem
kap értéket.
\begin{alltt}
| ?- X#>3 #<=> B, X in 3..4.       \(\Rightarrow\) B in 0..1
\end{alltt}
\item A rendszer kikövetkezteti, hogy az adott tárban \cd{X} és \cd{Y} távolsága legalább \cd{1}:
\begin{alltt}
| ?- abs(X-Y)#>1 #<=> B, X in 1..4, Y in 6..10.
             \(\Rightarrow\) B = 1
\end{alltt}
\item Bár a távolság-feltétel itt is fennáll, a rendszer nem veszi észre!
\begin{alltt}
| ?- abs(X-Y)#>1 #<=> B, X in \{1,5\}, Y in \{3,7\}.
             \(\Rightarrow\) B in 0..1 
\end{alltt}
\item Ennek itt az az oka, hogy az aritmetika nem tartomány-konzisztens.
\begin{alltt}
| ?- D #= X-Y, 
     AD #= abs(D), AD#>1 #<=> B, 
     X in \{1,5\}, Y in \{3,7\}.
             \(\Rightarrow\) D in -6..2, AD in 0..6, B in 0..1
\end{alltt}
\begin{alltt}
| ?- plus(Y, D, X),      \(\Leftarrow\){\rm tartomány-konzisztens összegkorlát}
     AD #= abs(D), AD#>1 #<=> B, 
     X in \{1,5\}, Y in \{3,7\}.
             \(\Rightarrow\) D in \{-6,-2,2\}, AD in \{2,6\}, B = 1
\end{alltt}
\end{itemize}

\subsection{Levezethetõségi szintek}

\label{levezethetoseg}

A SICStus Prolog kétfajta levezethetõségi szintet ismer, a tartományszûkítés
és az intervallum-szûkítés fogalmához hasonlóan:
\br
\definicio a $C$ $n$-változós korlát \emph{tartomány-levezethetõ} az $s$ tárból,
ha változóinak $s$-ben megengedett tetszõleges $V_j \in D(X_j,s)$ értékkombinációjára
($j = 1, \ldots, n$) $C(V_1, \ldots V_n)$ fennáll.
\br
\definicio a $C$ $n$-változós korlát \emph{intervallum-levezethetõ} az $s$ tárból,
ha változóinak $s$-ben megengedett tetszõleges $V_j \in D'(X_j,s)$ értékkombinációjára
($j = 1, \ldots, n$) $C(V_1, \ldots V_n)$ fennáll.
\br
A fentiekbõl a $D(x_j,s) \subseteq D'(x_j,s)$ relációt figyelembe véve következik, hogy
ha $C$ intervallum-levezethetõ, akkor tartomány-levezethetõ is. A kétféle levezethetõségi
vizsgálatra azért van szükség, mert a tartomány-levezethetõség vizsgálata általában
bonyolultabb (és tovább is tart), mint az intervallum-levezethetõségé. Például az
\cd{X \#\bs= Y} korlát tartomány-levezethetõ, ha \cd{X} és \cd{Y} tartományai
diszjunktak (a tartományok méretével arányos költség), ugyanakkor az
intervallum-levezethetõséghez elég az \cd{X} és \cd{Y} tartományainak lefedõ
intervallumait vizsgálni (ami konstans költségû mûvelet).
\br
A SICStus-ban a tükrözött halmazkorlátok kiderítik a tartomány-levezethetõséget, a
tükrözött \emph{lineáris} aritmetikai korlátok legalább az intervallum-levezethetõséget
(egyes esetekben a tartomány-levezethetõséget is, lásd az elõzõ alfejezet utolsó 4
példáját). A tükrözött nemlineáris aritmetikai korlátokra még az intervallum-levezethetõség
kiderítése sem garantálható.

\subsection{Egy bonyolultabb \clpfd példa: mágikus sorozatok}

\definicio egy $L = (x_{0}, x_{1}, \ldots, x_{n-1})$ sorozat \emph{mágikus}
($x_{i} \in [0..n-1]$), ha minden $i \in [0..n-1]$-re $L$-ben az $i$ szám pontosan
$x_{i}$-szer fordul elõ.
\br
{\bf Példa:} $n$=4 esetén (1,2,1,0) és (2,0,2,0) mágikus sorozatok.
\br
A feladat \clpfd megoldásához definiálni fogunk a sorozatok között egy transzformációt:
\br
\definicio az $X = (x_{0}, x_{1}, \ldots, x_{n-1})$ sorozatnak az
$Y = \mathcal{E}(X) = (y_{0}, y_{1}, \ldots, y_{n-1})$ sorozat az
\emph{elõfordulás-sorozat}a, ha minden $i \in [0..n-1]$-re $X$-ben az $i$ szám
pontosan $y_{i}$-szer fordul elõ.

\subsubsection{Egyszerû \clpfd megoldás}

Látható, hogy a mágikus sorozatok azok a sorozatok, amelyek erre a $\mathcal{E}$
transzformációra nézve fixpontok (azaz olyan sorozatok, amelyeket a transzformáció
önmagába visz át). Ennek felhasználásával a feladatra könnyen adható egy néhány
soros \clpfd megoldás:

\begin{alltt}
% Az L lista egy N hosszúságú mágikus sorozat.
magikus(N, L) :-
        length(L, N), N1 is N-1, domain(L, 0, N1),
        elofordulasok(L, 0, L),
        labeling([], L).             % most felesleges

% elofordulasok([E\(_\cd{i}\), E\(_\cd{i+1}\), \ldots], i, Sor): Sor-ban az i
% szám E\(_\cd{i}\)-szer, az i+1 szám E\(_\cd{i+1}\)-szer stb. fordul elõ.
% Ez a predikátum valósítja meg a fenti elõfordulás-sorozat transzformációt
elofordulasok([], _, _).
elofordulasok([E|Ek], I, Sor) :-
        pontosan(I, Sor, E), 
        J is I+1, elofordulasok(Ek, J, Sor).

% pontosan(I, L, E): Az I szám L-ben E-szer fordul elõ.
pontosan(I, L, 0) :- outof(I, L).
pontosan(I, [I|L], N) :- 
        N #> 0, N1 #= N-1, pontosan(I, L, N1).
pontosan(I, [X|L], N) :- 
        N #> 0, X #\bs= I, pontosan(I, L, N).

% outof(I, L): Az I szám L-ben nem fordul elõ.
outof(_, []).
outof(X, [Y|Ys]) :- X #\bs= Y, outof(X, Ys).
\end{alltt}

Példafutás (csak a \cd{pontosan/3} hívások érdekelnek minket):

\begin{verbatim}
| ?- spy pontosan/3, magikus(4, L).
 +      1      1 Call: pontosan(0,[_A,_B,_C,_D],_A) ? s
?+      1      1 Exit: pontosan(0,[1,0,_C,_D],1) ? z
 +      2      1 Call: pontosan(1,[1,0,_C,_D],0) ? s
 +      2      1 Fail: pontosan(1,[1,0,_C,_D],0) ? z
 +      1      1 Redo: pontosan(0,[1,0,_C,_D],1) ? s
?+      1      1 Exit: pontosan(0,[2,0,0,_D],2) ? z
(...)
 +      4      1 Call: pontosan(2,[2,0,0,_D],0) ? s
 +      4      1 Fail: pontosan(2,[2,0,0,_D],0) ? z
(...)
?+      1      1 Exit: pontosan(0,[3,0,0,0],3) ? z
(...)
?+      1      1 Exit: pontosan(0,[2,0,_D,0],2) ?
\end{verbatim}

\subsubsection{Redundáns korlátok bevezetése}

A fenti változat hatékonyságán sokat segíthetünk \emph{redundáns korlátok}
felvételével. A redundáns korlátok olyan korlátok, amelyek formálisan nem
közölnek új információt a feladatról, hanem a már fennálló korlátok következményei,
azonban úgy vannak ,,megfogalmazva'', hogy ezzel segítik a program végrehajtását,
mert olyan esetekben is szûkítéseket eredményeznek, amikor a redundancia nélküli
változat erre nem volt képes. A redundáns korlátokhoz a következõ állítást
fogjuk felhasználni:
\br
\tetel ha az $L = (x_{0}, x_{1}, \ldots, x_{n-1})$ sorozat mágikus,
akkor $\sum_{i<n} x_{i} = n$ és $\sum_{i<n} i \times x_{i} = n$.
\br
Ezzel a program fõ klóza a következõképpen módosul:
\begin{alltt}
% Az L lista egy N hosszú mágikus sorozat
magikus2(N, L) :-
    length(L, N), N1 is N-1, domain(L, 0, N1),
    osszege(L, S),               % \(\sum_{i\in [1..\cd{N}]} L_{i} = \cd{S}\)
    szorzatosszege(L, 0, SP),    % \(\sum_{i\in [1..\cd{N}]} i*L_{i} = \cd{SP}\)
    call(S #= N), call(SP #= N), % lásd a megjegyzést
    elofordulasok(L, 0, L).      % lásd az elõzõ lapon

% osszege(L, Ossz): Ossz = \(\sum_i \cd{L}_i\)
osszege([], 0).
osszege([X|L], X+S) :- osszege(L, S).

% szorzatosszege(L, I, Ossz): Ossz = \(\cd{I}*\cd{L}_1+\cd{(I+1)}*\cd{L}_2+\ldots\)
szorzatosszege([], _, 0).
szorzatosszege([X|L], I, I*X+S) :- 
    J is I+1, szorzatosszege(L, J, S).
\end{alltt}

Az \cd{osszege/2} és a \cd{szorzatosszege/3} hívásokat külön nem fejtjük ki, ezek
a megfelelõ korlát-kifejezéseket \emph{építik fel} az \cd{S} és \cd{SP} változókba.
A \cd{call/1} alkalmazására azért van szükség, mert a korlátokat a \clpfd könyvtár
fordítási idõben átalakítja a saját, belsõ formátumára, és ez a felhasználó által
futásidõben felépített korlátokra nem történik meg. A megoldást a korlátkifejtési
fázis késleltetése jelenti a \cd{call/1} segítségével. Egyébként a programnak ez a
változata \cd{N=10} esetben kb. ötvenszer gyorsabb az elõzõ verziónál, és a 4 hosszú
mágikus sorozatok közül az elsõ megoldást visszalépés nélkül adja ki!

\subsubsection{Tükrözéses megoldás}

A tükrözés mechanizmusának felhasználásával egy elegáns, ráadásul hatékonyabb
megfogalmazást is adhatunk a \cd{pontosan/3} eljárásra, és ezzel az egész
feladatra:

\begin{verbatim}
magikus3(N, L) :-
        length(L, N), 
        N1 is N-1, domain(L, 0, N1),
        osszege(L, S), call(S #= N), 
        szorzatosszege(L, 0, SS), call(SS #= N),
        elofordulasok3(L, 0, L),
        labeling([], L). % most már kell a címkézés!

% A korábbi elofordulasok/3 másolata
elofordulasok3([], _, _).
elofordulasok3([E|Ek], I, Sor) :-
        pontosan3(I, Sor, E), 
        J is I+1, elofordulasok3(Ek, J, Sor).

% pontosan3(I, L, E): L-ben az I E-szer fordul elõ.
pontosan3(_, [], 0).
pontosan3(I, [X|L], N) :-
        X #= I #<=> B, N #= N1+B, pontosan3(I, L, N1).
\end{verbatim}

A megoldás lényege, hogy a \cd{pontosan3/3} eljárásban az \cd{L} lista
minden \cd{X} elemére felveszünk egy \cd{X \#= I} korlátot, és ennek igazságértékét
egy \cd{B} változóban tükrözzük. Az összes \cd{B} érték összegének pontosan
\cd{E}-vel kell megegyeznie. Ezzel a megoldással sikerült kiszûrni a \cd{pontosan/3}
eljárásból az eddig meglévõ diszjunkciót, és ezzel sokkal hatékonyabb kódot
sikerült készítenünk, ami az alábbi összehasonlító táblázatból is látszik
(1 perc idõkorlát, Pentium III 600 MHz-es processzor):

\begin{center}
\begin{tabular}{|l|rrrrrr|}
\hline
variáns/adat                   & n=10  & n=20 & n=40  & n=80  & n=160 & n=320 \\
\hline                         
választós                      & 13.90 & ---  &  ---  &  ---  & ---  & ---    \\
választós+\cd{osszege}         &  0.22 & ---  &  ---  &  ---  & ---  & ---    \\
vál.+\cd{szorzatosszege}       &  0.02 & 0.55 & 44.04 &  ---  & ---  & ---    \\
vál.+\cd{ossz}+\cd{szorzossz}  &  0.02 & 0.29 & 17.98 &  ---  & ---  & ---    \\
tükrözéses                     &  0.05 & 1.07 & 24.02 &  ---  & ---  & ---    \\
tükrözéses+\cd{osszege}        &  0.01 & 0.14 &  1.71 & 20.15 & ---  & ---    \\
tükr.+\cd{szorzatosszege}      &  0.01 & 0.04 &  0.18 &  0.94 & 4.75 & 25.77  \\
tükr.+\cd{ossz}+\cd{szorzossz} &  0.01 & 0.05 &  0.19 &  0.95 & 4.61 & 23.57  \\
\hline
\end{tabular}
\end{center}

\subsection{Logikai korlátok}

Annak ellenére, hogy a \clpfd könyvtár alapvetõen véges, egész értékû tartományok 
kezelésére használatos, lehetõség van logikai korlátok használatára is. Logikai
korlátokat háromféle alkotóelembõl építhetünk fel:

\begin{itemize}
\item változókból, ilyenkor a változók tartománya automatikusan a 0..1 tartományra
szûkül (a 0 a logikai hamis, az 1 a logikai igaz értéket fogja jelenteni)
\item tükrözhetõ aritmetikai- vagy halmazkorlátokból
\item más logikai korlátokból
\end{itemize}

Ezen építõelemek összekapcsolására az alábbi operátorok használatosak:

\begin{center}\begin{tabular}{|l|l|l|}
\hline
\verb'#\ Q'     &           negáció\ \ \ \ \ & \verb'op(710,  fy, #\).'\\
\verb'P #/\ Q'  &           konjunkció       & \verb'op(720, yfx, #/\).'\\
\verb'P #\ Q'   &           kizáró vagy      & \verb'op(730, yfx, #\).'\\
\verb'P #\/ Q'  &           diszjunkció      & \verb'op(740, yfx, #\/).'\\
\verb'P #=> Q'  &           implikáció       & \verb'op(750, xfy, #=>).'\\
\verb'Q #<= P'  &           implikáció       & \verb'op(750, yfx, #<=).'\\
\verb'P #<=> Q' &           ekvivalencia     & \verb'op(760, yfx, #<=>).'\\
\hline
\end{tabular}\end{center}

Észrevehetjük, hogy a korlátok igazságértékének tükrözésére használt \cd{\#<=>}
operátor jelen van a fenti táblázatban is. Ennek az az oka, hogy a tükrözési
jelölés valójában a logikai korlát-fogalom speciális esete. Fontos azonban megjegyezni,
hogy az \emph{összes} logikai korlát a \cd{$C$ \#<=> B} alakú \emph{elemi}
korlátra vezetõdik vissza. Például:

\begin{center}
\cd{X \#= 4 \#\bs/ Y \#> 6 $\Longleftrightarrow$ X \#= 4 \#<=> B1, Y \#> 6 \#<=> B2, B1+B2 \#> 0}
\end{center}

{\bf Vigyázat!} A diszjunktív logikai korlátok gyengén szûkítenek: egy $n$-tagú
diszjunkció csak akkor tud szûkíteni, ha egy kivételével valamennyi tagjának a
negáltja levezethetõvé válik (a fenti példában akkor, ha \cd{X \#\= 4} vagy \cd{Y \#\=< 6}
levezethetõ lesz).

\subsection{Példa a logikai korlátokra: lovagok, lókötõk és normálisak}

Egy szigeten minden bennszülött lovag, lókötõ, vagy normális. A lovagok mindig
igazat mondanak, a lókötõk mindig hazudnak, a normális emberek pedig néha
hazudnak, néha igazat mondanak. Adott három bennszülött, $A$, $B$ és $C$, akik
közül egy lovag, egy lókötõ és egy normális (de nem feltétlenül ebben a sorrendben).
Az alábbi állításokat teszik:

\begin{center}\begin{tabular}{ccc}
$A$: Én normális vagyok. & $B$: $A$ igazat mond. & $C$: Én nem vagyok normális.
\end{tabular}\end{center}

Kérdés: melyikõjük lovag, melyikõjük lókötõ és melyikõjük normális?
\br
A \clpfd megoldás során alkalmazzuk az alábbi kódolást: normális $\to$ \cd{2},
lovag $\to$ \cd{1}, lókötõ $\to$ \cd{0} (ez azért jó, mert így minden lovag
állítása az 1-es igazságértékbe, és minden lókötõ állítása a 0-s igazságértékbe
tükrözhetõ, ami megegyezik a hozzájuk rendelt azonosítóval).

\begin{verbatim}
:- use_module(library(clpfd)).

% Bevezetünk néhány operátort az állítások egyszerûbb leírására.
:- op(700, fy, nem).     :- op(900, yfx, vagy).  
:- op(800, yfx, és).     :- op(950, xfy, mondja).

% A B bennszülött mondhatja az Áll állítást.
B mondja Áll :- értéke(B mondja Áll, 1).

% értéke(A, Érték): Az A állítás igazságértéke Érték.
értéke(X = Y, E) :-
    X in 0..2, Y in 0..2, E #<=> (X #= Y).
értéke(X mondja M, E) :-
    X in 0..2, értéke(M, E0), 
    E #<=> (X #= 2 #\/ E0 #= X).
értéke(M1 és M2, E) :-
    értéke(M1, E1), értéke(M2, E2), E #<=> E1 #/\ E2.
értéke(M1 vagy M2, E) :-
    értéke(M1, E1), értéke(M2, E2), E #<=> E1 #\/ E2.
értéke(nem M, E) :-
        értéke(M, E0), E #<=> #\E0.

| ?- all_different([A,B,C]), A mondja A = 2, 
     B mondja A = 2, C mondja nem C =2,
     labeling([], [A,B,C]).
A = 0, B = 2, C = 1 ? ;
no
\end{verbatim}

\subsection{További globális aritmetikai korlátok}

Az eddigiek során már megismerkedhettünk két globális korláttal: az \cd{all_different/1}
és az \cd{all_distinct/1} korlátokkal. A SICStus azonban ismer még néhány hasznos
globális aritmetikai korlátot is, amelyeket ebben a fejezetben fogunk bemutatni. Ezen
korlátok közös jellemzõje, hogy a többi globális korláthoz hasonlóan nem tükrözhetõek.

\begin{itemize}
\item \cd{scalar_product(Coeffs, Xs, RelOp, Value)} \\
Igaz, ha a \cd{Coeffs} egészekbõl álló együttható-lista és az \cd{Xs} korlát-változókból
és egészekbõl álló lista skalárszorzata a \cd{RelOp} relációban áll a \cd{Value}
értékkel (\cd{Value} lehet egész szám vagy korlát-változó). \cd{RelOp} egy tetszõleges
aritmetikai összehasonlító operátor (pl. \cd{\#=}, \cd{\#<} stb.). Intervallum-szûkítést
biztosít. Érdekességként megjegyezzük, hogy minden lineáris aritmetikai korlát
átalakítható egy megfelelõ \cd{scalar_product} hívássá.

\item \cd{sum(Xs, RelOp, Value)} \\
Igaz, ha az \cd{Xs} korlát-változókból és egészekbõl álló lista összege a \cd{RelOp}
relációban áll a \cd{Value} értékkel (\cd{Value} lehet egész szám vagy korlát-változó).
Megegyezik a \cd{scalar_product(Csupa1, Xs, RelOp, Value)} hívással, ahol \cd{Csupa1}
csupa 1-es számból álló lista, és a hossza megegyezik \cd{Xs} hosszúságával.

\item \cd{knapsack(Coeffs, Xs, Value)} \\
Jelentése: \cd{Coeffs} és \cd{Xs} skalárszorzata \cd{Value}. Csak nem-negatív
számok és véges tartományú változók megengedettek, viszont cserébe tartomány-konzisztenciát
biztosít.
\end{itemize}

A \ref{sendmoremoney}. fejezetben ismertetett kódaritmetika példa egyszerûbb megoldása
\cd{scalar_product/4} segítségével:

\begin{verbatim}
send(List, SEND, MORE, MONEY) :-
        List= [S,E,N,D,M,O,R,Y], 
        Pow10 = [1000,100,10,1],
        all_different(List), S #\= 0, M#\= 0,
        scalar_product(Pow10, [S,E,N,D], #=, SEND),
        %   SEND #=  1000*S+100*E+10*N+D,
        scalar_product(Pow10, [M,O,R,E], #=, MORE),
        %   MORE #= 1000*M+100*O+10*R+E,
        scalar_product([10000|Pow10], [M,O,N,E,Y], 
                       #=, MONEY),
        %   MONEY #= 10000*M+1000*O+100*N+10*E+Y,
        SEND+MORE #= MONEY.
\end{verbatim}

\subsection{A formulakorlátok belsõ megvalósítása}
\label{korlatkif}

\definicio \emph{formulakorlát}oknak nevezzük az összes operátoros
jelöléssel írt korlátot, tehát az eddig tárgyalt összes korlátot, a
globális korlátok kivételével.
\br
Mint azt már a \ref{korlatvegrehajtas}. fejezet elején említettük, a
formulakorlátokat a SICStus \clpfd könyvtára elemi korlátok konjunkciójára
fordítja le a \cd{goal_expansion/3} kampó-eljárás segítségével. Ez az
eljárás minden formulakorlátot fordítási idõben a \cd{scalar_product/4}
korlátra és/vagy nem publikus elemi korlátokra fejt ki. Az átfordítás
futásidõig elhalasztható a korlát \cd{call/1}-be való ágyazásával, ez
a futás közben felépített formulakorlátok esetén hasznos.

\enumhead{A legfontosabb elemi korlátok a \cd{clpfd} modulban}
\begin{itemize}
\item aritmetika:\verb?'x+y=t'/3 'x*y=z'/3 'x/y=z'/3 'x mod y=z'/3?
\verb?'|x|=y'/2 'max(x,y)=z'/3 'min(x,y)=z'/3?
 \item összehasonlítás: \verb?'x=y'/2, 'x=<y'/2, 'x\\=y'/2?
és tükrözött változataik: \cd{iff\_aux('x {\em Rel} y'(X,Y), B)},
ahol {\tt\em Rel} $\in$ \{ \verb?= =< \=?\} .
\item halmazkorlátok: \cd{propagate_interval(X,Min,Max)
prune_and_propagate(X,Halmaz)}
\item logikai korlátok: \cd{bool(Muvkod,X,Y,Z)} (jelentése: \cd{X Muv Y = Z})
\item optimalizálások: \cd{'x*x=y'/2 'ax=t'/3 'ax+y=t'/4 'ax+by=t'/5
't+u=<c'/3 't=u+c'/3 't=<u+c'/3 't\bs=u+c'/3 't>=c'/2} stb.
\end{itemize}

\label{pontszukites}
A legtöbb elemi korlát \emph{pontszûkítõ}. A pontszûkítés definíciója
a következõképpen hangzik: egy $C$ korlát \emph{pontszûkítõ}, ha minden
olyan tár esetén tartományszûkítõ, amelyben $C$ változói legfeljebb
egy kivétellel be vannak helyettesítve (másképpen: minden ilyen tár esetén
a korlát a behelyettesítetlen változót pontosan a $C$ reláció által
megengedett értékekre szûkíti). Az egyetlen, nem pontszûkítõ elemi
korlát a \cd{mod}.
\br
Lineáris korlátok esetén a kifejtés megõrzi a pont-, illetve az
intervallum-szûkítést, általános esetben azonban még a pont-szûkítést
sem õrzi meg, pl:

\begin{verbatim}
| ?- X in 0..10, X*X*X*X #= 16.
X in 1..4 ? ;
no
\end{verbatim}

A korlátkifejtés mechanizmusát a \cd{goal_expansion/4} segédeljárás
hívásával magunk is megvizsgálhatjuk:

\begin{verbatim}
| ?- use_module(library(clpfd)).
| ?- goal_expansion(X*X+2*X+1 #= Y, user, G).
        G = clpfd:('x*x=y'(X,_A),
            scalar_product([1,-2,-1],[Y,X,_A],#=,1)) ? 

| ?- goal_expansion((X+1)*(X+1) #= Y, user, G).
        G = clpfd:('t=u+c'(_A,X,1),'x*x=y'(_A,Y)) ? 

| ?- goal_expansion(abs(X-Y)#>1, user, G).
        G = clpfd:('x+y=t'(Y,_A,X),
               '|x|=y'(_A,_B),'t>=c'(_B,2)) ? 

| ?- goal_expansion(X#=4 #\/ Y#>6, user, G).
        G = clpfd:iff_aux(clpfd:'x=y'(X,4),_A),
               clpfd:iff_aux(clpfd:'x=<y'(7,Y),_B),
               clpfd:bool(3,_A,_B,1) ?  % 3 a \/ kódja

| ?- goal_expansion(X*X*X*X #= 16, user, G).
        G = clpfd:('x*x=y'(X,_A),'x*y=z'(_A,X,_B),
                      'x*y=z'(_B,X,16)) ? 

| ?- goal_expansion(X in {1,2}, user, G).
        G = clpfd:propagate_interval(X,1,2) ? 

| ?- goal_expansion(X in {1,2,5}, user, G).
        G = clpfd:prune_and_propagate(X,[[1|2],[5|5]]) ?
\end{verbatim}

\subsection{Segédeljárások a \Clpfd -ben}

\enumhead{Statisztika}
\begin{itemize}
\item {\tt fd\_statistics(Kulcs, Érték)}: A \cd{Kulcs}-hoz tartozó
        számláló értékét \cd{Érték}-ben kiadja, és a számlálót lenullázza.
        Lehetséges kulcsok és számlált események: 
\begin{itemize}
\item \cd{constraints} --- korlát létrehozása
\item \cd{resumptions} --- korlát felébresztése
\item \cd{entailments} --- korlát (vagy negáltja) levezethetõvé válásának
        észlelése
\item \cd{prunings}    --- tartomány szûkítése
\item \cd{backtracks}  --- a korlát-tár ellentmondásossá válása miatt
        bekövetkezõ visszalépés (tehát Prolog meghiúsulások nem számítanak).
\end{itemize}
\item \cd{fd\_statistics}: az összes számláló állását kiírja és
        lenullázza õket.
\end{itemize}

Példa:

\begin{alltt}
% Az N-királynõ feladat összes megoldása Ss, Lab címkézéssel való
% végrehajtása Time msec-ig tart és Btrks FD visszalépést igényel.
run_queens(Lab, N, Ss, Time, Btrks) :-
        fd_statistics(backtracks, _), statistics(runtime, _),
        findall(Q, queens(Lab, N, Q), Ss),
        statistics(runtime, [_,Time]),
        fd_statistics(backtracks, Btrks).
\end{alltt}

\enumhead{A még le nem futott, alvó korlátok kiírása a válaszban)}
\begin{itemize}
\item \cd{clpfd:full\_answer}: ez egy dinamikus kampó eljárás.
        Alaphelyzetben nincs egy klóza sem, tehát nem sikerül. Ez
        esetben a rendszer egy kérdésre való válaszoláskor csak a
        kérdésben elõforduló változók tartományát írja ki, az alvó
        korlátokat nem. Ha felveszünk egy ilyen eljárást és az sikeresen
        fut le, akkor a válaszban az összes változó mellett kiírja még a
        le nem futott összes korlátot is.  
\end{itemize}

\begin{alltt}
| ?- domain([X,Y], 1, 10), X+Y#=5. \(\Rightarrow\) X in 1..4, Y in 1..4 ? 
| ?- assert(clpfd:full_answer).    \(\Rightarrow\) yes
| ?- domain([X,Y], 1, 10), X+Y#=5. \(\Rightarrow\) clpfd:'t+u=c'(X,Y,5), 
                                      X in 1..4, Y in 1..4 ? 
| ?- X+Y #= Z #<=> B.              \(\Rightarrow\) clpfd:'t=u IND'(Z,_A)#<=>B,
                                      clpfd:'x+y=t'(X,Y,_A), B in 0..1, \ldots
| ?- retract(clpfd:full_answer).   \(\Rightarrow\) yes
| ?- X+Y #= Z #<=> B.              \(\Rightarrow\) B in 0..1, \ldots
\end{alltt}

\subsection{FD-változók és FD-halmazok}
\label{fdset}

\definicio \emph{FD-változó}nak nevezünk minden olyan Prolog változót,
amely a korlát-tár korlátaiban szerepel, és ezért a \clpfd könyvtár különbözõ
információkat tart fenn róla. Az FD-változókról tárolt információkat a
programban felhasználhatjuk, de nagy valószínûséggel csak a címkézésnél,
nyomkövetésnél, illetve globális korlátokban látjuk hasznukat.
\br
Az FD-változókkal kapcsolatban a következõ eljárásokat érdemes ismerni:

\begin{itemize}
\item \cd{fd\_var(V)}: \cd{V} egy, a \clpfd könyvtár által ismert változó.
\item \cd{fd\_min(X, Min)}: a \cd{Min} paramétert egyesíti az \cd{X}
változó tartományának alsó határával (ez egy szám vagy \cd{inf} lehet).
\item \cd{fd\_max(X, Max)}: a \cd{Max} paramétert egyesíti az \cd{X}
változó tartományának felsõ határával (ez egy szám vagy \cd{sup} lehet).
\item \cd{fd\_size(X, Size)}: \cd{Size} az \cd{X} tartományának számossága
(szám vagy \cd{sup}).
\item \cd{fd\_dom(X, Range)}: \cd{Range} az \cd{X} változó tartománya,
tartománykifejezés formában 
\item \cd{fd\_set(X, Set)}: \cd{Set} az \cd{X} tartománya úgynevezett
\emph{FD-halmaz} formában (ld. lejjebb).
\item \cd{fd\_degree(X, D)}: \cd{D} az \cd{X}-hez kapcsolódó korlátok
száma.
\end{itemize}

Néhány példa a fentiek használatával:

\begin{verbatim}
| ?- X in (1..5)\/{9}, fd_min(X, Min), fd_max(X, Max), fd_size(X, Size).
Min = 1, Max = 9, Size = 6, X in(1..5)\/{9} ? 
| ?- X in (1..9)/\ \(6..8), fd_dom(X, Dom), fd_set(X, Set).
Dom = (1..5)\/{9}, Set = [[1|5],[9|9]], X in ... ?
| ?- queens_nolab(8, [X|_]), fd_degree(X, Deg).
Deg = 21, X in 1..8 ?         % mivel 21 = 7*3
\end{verbatim}

A pár sorral elõbb említett \emph{FD-halmaz}ok a \clpfd könyvtárban a
tartományok belsõ ábrázolási formáját jelentik. Jelenleg egy FD-halmaz
\cd{[Alsó|Felsõ]} alakú szeparált zárt intervallumok rendezett listája (mivel
a \cd{.(_,_)} struktúra memóriaigénye 33\%-kal kisebb, mint bármely más
\cd{f(_,_)} struktúráé), ezt azonban \emph{szigorúan tilos} kihasználni, nem
szabad ilyen adatszerkezetet a rendelkezésre álló könyvtári eljárásokon
kívül más módszerrel létrehozni vagy megváltoztatni! Az ilyen jellegû
megoldások elõbb-utóbb \cd{segmentation violation} vagy hasonló jellegû
hibaüzenethez vezetnek.
\br
Az adattípus manipulálására szolgáló könyvtári eljárások:

\begin{itemize}
\item \cd{is\_fdset(S)}: \cd{S} egy korrekt FD-halmaz.
\item \cd{empty\_fdset(S)}: \cd{S} az üres FD-halmaz.
\item \cd{fdset\_singleton(S,E)}: \cd{S} egyedül az \cd{E} elemet tartalmazza.
\item \cd{fdset\_interval(Set, Min, Max)}: \cd{S} egyedül a \cd{Min..Max}
intervallum elemeit tartalmazza
\item \cd{empty\_interval(Min, Max)}: \cd{Min..Max} egy üres intervallum
(ekvivalens a \cd{\bs+ fdset\_interval(_, Min, Max)} hívással).
\item \cd{fdset\_parts(S, Min, Max, Rest)}: Az \cd{S} FD-halmaz áll egy
\cd{Min..Max} kezdõ intervallumból és egy \cd{Rest} maradék FD-halmazból, ahol
\cd{Rest} minden eleme nagyobb \cd{Max+1}-nél. Egyaránt használható
FD-halmaz szétszedésére és építésére.
\begin{verbatim}
| ?- X in (1..9) /\ \(6..8), fd_set(X, _S), 
     fdset_parts(_S, Min1, Max1, _).
         Min1 = 1, 
         Max1 = 5, 
         X in(1..5)\/{9} ? 
\end{verbatim}
\item \cd{fdset\_union(Set1, Set2, Union)}: \cd{Set1} és \cd{Set2}
uniója \cd{Union},  
\cd{fdset\_union(ListOfSets, Union)}: a \cd{ListOfSets} FD halmazokból
álló lista elemeinek uniója \cd{Union}.
\item \cd{fdset\_intersection/[3,2]} : Két halmaz, illetve egy listában
megadott halmazok metszete (analóg az \cd{fdset\_union/[3,2]}-vel)
\item \cd{fdset\_complement(Set1, Set2)}: \cd{Set1} és \cd{Set2} egymás
komplemensei
\item \cd{fdset\_member(Elt, Set)}: \cd{Elt} eleme a \cd{Set} FD-halmaznak.
Visszalépésre az összes elemet felsorolja
\item \cd{list_to_fdset(List, Set), fdset_to_list(Set, List)}: számlista
átalakítása FD-halmazzá, és fordítva.
\item \cd{range_to_fdset(Range, Set), fdset_to_range(Set, Range)}:
tartománykifejezés átalakítása FD-halmazzá és viszont.
\end{itemize}

Itt jegyeznénk meg, hogy egy FD-halmaz szintén felhasználható egy változó
tartományának szûkítésére az \cd{X in_set Set} hívás használatával, azonban
vegyük figyelembe, hogy ha \cd{Set}-et egy \cd{Y} változó tartományának
függvényében alakítjuk ki, akkor ezzel még nem érünk el ,,démoni'' hatást,
mivel a szûkítés csak \cd{Y} tartományának aktuális állásától függõen
fog végrehajtódni. Az \cd{in_set} szûkítés leginkább globális korlátokban
és testreszabott címkézésnél használatos.

\subsection{A címkézés (labeling) testreszabása}

Elevenítsük fel a CLP programok szerkezetére vonatkozóan tett megállapításainkat!
Egy CLP programot három fõ részre lehet szeparálni:

\begin{enumerate}
\item Változók felvétele és tartományaik megadása
\item Korlátok felvétele (lehetõség szerint választási pontok nélkül)
\item Címkézés, azaz a változók lehetséges értékeinek valamilyen rendszer szerint
történõ behelyettesítése
\end{enumerate}

Ebben a fejezetben a 3. lépés lehetséges megvalósításaival fogunk foglalkozni.
A címkézés során adott egy változóhalmaz, amelyben minden változónak egy lehetséges
értékkészlete van. Egy \emph{címkézési lépés}ben a következõ teendõket végezzük el:

\begin{enumerate}
\item Kiválasztunk a címkézendõ változók közül egyet
\item A kiválasztott változó értékkészletét olyan diszjunkt részhalmazokra bontjuk,
amelyek egyesítése kiadja az eredeti értékkészletet (\emph{particionálás})
\item Ezen partíciókkal egy választási pontot hozunk létre, a választási pontból
kivezetõ ágak mindegyike az adott változó értékkészletét az egyik partícióra
szûkíti le. Az ágakat a hagyományos Prolog végrehajtás szabályai szerint járjuk
be, figyelembe véve azt, hogy amikor egy ágat kiválasztunk, és a változó értékét
az adott partícióra szûkítjük, akkor ez többnyire különbözõ korlátok felébredését
okozza, amelyek meghiúsulást válthatnak ki. Ha a szûkítés sikeresen lefutott, akkor
jöhet a következõ címkézési lépés. (Megjegyzés: ha a kiválasztott változó
értékkészlete még nem egyetlen számból áll, akkor semmi nem zárja ki azt, hogy a
következõ címkézési lépésben ugyanezt a változót válasszuk)
\end{enumerate}

A keresés célja többféle lehet. Elõfordulhat, hogy az \emph{összes} megoldást meg
szeretnénk keresni, elõfordulhat, hogy egy \emph{tetszõleges} megoldásra vagyunk kíváncsiak,
és az is megeshet, hogy a megoldások közül valamilyen szempontból a \emph{legoptimálisabb}at
keressük. Arra azonban mindenképp törekednünk kell, hogy ez(eke)t a megoldás(oka)t a lehetõ
legkevesebb visszalépés végrehajtásával, a lehetõ legrövidebb idõ alatt találjuk meg.
Ebben segít a keresési stratégia testreszabása. A testreszabás három szempont szerint
történhet:

\begin{itemize}
\item A címkézési lépés elején a változó kiválasztásának módjával
\item A választási pont fajtájával (kétszeres, többszörös), valamint az egyes ágakhoz
hozzárendelt tartományokkal
\item A választási pontok ágainak bejárási irányával
\end{itemize}

Nézzük meg egy egyszerû példán, hogy hogyan függ a keresési tér mérete a változó
kiválasztásának módjától!
\br
{\tt | ?- }\parbox[t]{0.3\textwidth}{\tt
X in 1..4, 
Y in 1..2,\\
indomain(X),\\
indomain(Y).
}\raisebox{-1.5ex}{\parbox[c]{0.2\textwidth}{%\vspace*{-1ex} 
\epsfig{file=cimke1.eps,width=0.2\textwidth}}}
\br
{\tt | ?- }\parbox[t]{0.3\textwidth}{\tt
X in 1..4, 
Y in 1..2,\\
indomain(Y),\\
indomain(X).
}\raisebox{-1.5ex}{\parbox[c]{0.2\textwidth}{%\vspace*{-1ex} 
\epsfig{file=cimke2.eps,width=0.2\textwidth}}}
\br
Ha feltételezzük, hogy a fenti keresés során egyes ágak meghiúsulhatnak, akkor könnyen
rájöhetünk, hogy érdemesebb a második ábra szerinti keresési teret választani, mert ha
itt a kezdõ csomópontból kimenõ egyik ág meghiúsul, akkor azzal már helybõl 4 eset
ellenõrzését spóroltuk meg. Ez az úgynevezett \emph{first-fail} elv: elõbb címkézzük
a kisebb tartományú változót, ezzel remélhetõleg kevesebb választási pont lesz,
csökken a keresési tér mérete. Az is elõfordulhat, hogy egyes feladattípusokhoz saját,
speciális sorrend a célszerû: például az N királynõ feladatban célszerû elõbb a középsõ
sorokba elhelyezni a királynõket, mert ezek jobban megszûrik a maradék változók
értékkészletét, mint a szélsõ sorokba helyezett királynõk.
\br
A \clpfd könyvtár beépített címkézõ eljárása, a \cd{labeling/2} az elsõ paraméterként
átadott címkézési opció-listán keresztül lehetõséget ad arra, hogy a keresési tér
szerkezetét befolyásoljuk. Három lehetõség közül választhatunk:

\begin{itemize}
\item \emph{Felsorolás (\cd{enum})} --- többszörös választási pontot hoz létre, pontosan
annyi ággal, ahány lehetséges értéke van a változónak. Egy ágon mindig ezen értékek
közül pontosan az egyikre történik behelyettesítés. Használatára példa: \\
\cd{| ?- X in 1..4, labeling([enum],[X]).}
\item \emph{Kettévágás (\cd{bisect})} --- a változó tartományát megfelezi, és két ágat hoz
létre, értelemszerûen a két résztartományra való behelyettesítésével. Használatára példa: \\
\cd{| ?- X in 1..4, labeling([bisect],[X]).}
\item \emph{Lépegetés (\cd{step})} --- kiválaszt a változó tartományából egy értéket,
és két ágat hoz létre. Az egyik ágon erre az értékre szûkíti a változó tartományát,
a másik ágon pedig ezt az értéket kizárja a változó tartományából. Használatára példa: \\
\cd{| ?- X in 1..4, labeling([step],[X]).}
\end{itemize}

Az alábbi ábrákon egy 1..4 értékkészlettel rendelkezõ változó különbözõ címkézéseibõl
adódó keresési terek láthatóak.

\label{kerfak}
\begin{center}\begin{tabular}{ccc}
\epsfig{file=vpont_enum.eps,width=0.095\textwidth} &
\epsfig{file=vpont_bisect.eps,width=0.1\textwidth} &
\epsfig{file=vpont_step.eps,width=0.1\textwidth} \\
Felsorolás (\cd{enum}) & Kettévágás (\cd{bisect}) & Lépegetés (\cd{step})
\end{tabular}\end{center}

Ezen ,,rövid'' bevezetõ után lássuk a \cd{labeling/2} címkézõ eljárás részletes
ismertetését!

\enumhead{A címkézés alap-eljárása:
\cd{labeling(Opciók, VáltozóLista)}}

A \cd{VáltozóLista} minden elemét minden lehetséges módon behelyettesíti,
az \cd{Opciók} lista által elõírt módon.  Az alábbi csoportok mindegyikébõl
legfeljebb egy opció szerepelhet. Hibát jelez, ha a \cd{VáltozóLista}-ban van
nem korlátos tartományú változó. Ha az elsõ négy csoport valamelyikébõl nem
szerepel opció, akkor a {\tt\em dõlt betûvel} szedett alapértelmezés lép életbe.

\begin{enumerate}
\item a változó kiválasztása: \cd{{\em leftmost}, min, max, ff, ffc,
variable(Sel)}. Ezek jelentése:
	\begin{itemize}
	\item \cd{leftmost} --- a változólista legbaloldalibb eleme.
	\item \cd{min} --- a legkisebb alsó határú. Ha több van, akkor ezek közül
	a legbaloldalibb.
	\item \cd{max} --- a legnagyobb felsõ határú. Ha több van, akkor ezek közül
	a legbaloldalibb.
	\item \cd{ff} --- \emph{first-fail} elv szerint a legkisebb tartományú
	(ld. \cd{fd_size/2} az \ref{fdset}. fejezetben). Ha több van, akkor ezek közül
	a legbaloldalibb.
	\item \cd{ffc} --- a legkisebb tartományú. Ha több ilyen van, akkor ezek
    	közül az, amelyikhez a legtöbb korlát kapcsolódik (\emph{most constrained} elv).
	Ha még mindig több ilyen van, akkor ezek közül a legbaloldalibb. Egy változóhoz
	kapcsolódó korlátok számát az \cd{fd_degree/2} adja meg (ld. \ref{fdset}. fejezet).
	\item \cd{variable(Sel)} --- testreszabott változó-kiválasztás: a következõ
	változó kiválasztása a \cd{Sel} felhasználói eljárás szerint történik. Bõvebben
	errõl a \pageref{variable:sel}. oldalon még lesz szó.
	\end{itemize}
\item a választási pont fajtája: \cd{{\em step}, enum, bisect, value(Enum)}. Ezek
jelentése:
	\begin{itemize}
	\item \cd{step} --- \cd{X \#= B} és \cd{X \#\bs= B} közti választás, ahol
	\cd{B} az \cd{X} tartományának alsó vagy felsõ határa, a bejárási iránytól
	függõen
	\item \cd{enum} --- többszörös választás \cd{X} lehetséges értékei közül
	\item \cd{bisect} --- \cd{X \#< M} és \cd{X \#>= M} közti választás, ahol
	\cd{M} az \cd{X} tartományának középsõ eleme.
	\item \cd{value(Enum)} --- testreszabott választás: \cd{Enum} egy felhasználói
	eljárás, amelynek szerepe, hogy leszûkítse X tartományát. Bõvebben errõl
	az \pageref{value:enum}. oldalon még lesz szó.
	\end{itemize}
\item a bejárási irány: \cd{{\em up}, down}. \cd{up} értelemszerûen alulról felfelé,
\cd{down} felülrõl lefelé járja be a tartományt. Csak \cd{step} típusú
címkézésnél van szerepe.
\item a keresett megoldások: \cd{{\em all}, minimize(X), maximize(X)}. Ezek jelentése:
	\begin{itemize}
	\item \cd{all} -- az összes megoldást megkeresi
	\item \cd{minimize(X)} -- azt a megoldást adja vissza, melyben \cd{X} értéke
	minimális.
	\item \cd{maximize(X)} -- azt a megoldást adja vissza, melyben \cd{X} értéke
	maximális.
	\end{itemize}
\item a gyûjtendõ statisztikai adat: \cd{assumptions(A)}. A keresés végén egyesíti
\cd{A} értékét a sikeres megoldáshoz vezetõ ágon lévõ változó-kiválasztások
számával (ami lényegében a keresési út hosszát jelenti).
\item a balszélsõ ágtól való eltérés korlátozása: \cd{discrepancy(D)}. Ezzel azt
korlátozzuk, hogy a keresés során maximum \cd{D}-szer választhatunk a választási
pontokban nem legbaloldalibb ágat. Akkor hasznos, ha a probléma megoldására van
valamiféle heurisztikánk, és úgy alakítjuk ki a keresési teret, hogy a heurisztika
szerinti optimális választást a legbaloldalibb ág tartalmazza. Mivel a heurisztika
nem teljesen tökéletes, ezért valamekkora eltérést megengedünk (ezt szabályozzuk
\cd{D} értékével). Ezt a módszert hívjuk \emph{Limited Discrepancy Search}-nek (LDS).
\end{enumerate}

A fenti pontokra való hivatkozással a \cd{labeling/2} eljárás pontos mûködése
így fest:

\label{labeling:lepesek}
\begin{description}
\item[a.]  Ha a változólista üres, akkor a címkézés sikeresen véget
ér. Egyébként kiválasztunk belõle egy \cd{X} elemet az 1. csoportbeli opció
által elõírt módon.
\item[b.] Ha \cd{X} behelyettesített, akkor a változólistából elhagyjuk, és az
{\bf a.} pontra megyünk.
\item[c.] Egyébként az \cd{X} változó tartományát felosztjuk két vagy több
diszjunkt részre a 2. csoportbeli opció szerint (kivéve \cd{value(Enum)}
esetén, amikor is azonnal az {\bf e.} pontra megyünk).
\item[d.] A tartományokat elrendezzük a 3. csoportbeli opció szerint.
\item[e.] Létrehozunk egy választási pontot, amelynek ágain sorra
leszûkítjük az \cd{X} változót a kiválasztott tartományokra.
\item[f.] Minden egyes ágon az \cd{X} szûkítése értelemszerûen kiváltja a
rá vonatkozó korlátok felébredését. Ha ez meghiúsulást okoz, akkor
visszalépünk az {\bf e.} pontra és ott a következõ ágon folytatjuk.
\item[g.] Ha \cd{X} most már behelyettesített, akkor elhagyjuk a változólistából.
Ezután mindenképpen folytatjuk az {\bf a.} pontnál.
\item[h.] Eközben értelemszerûen követjük a 4-6. csoportbeli opciók elõírásait is.
\end{description}

Lássunk egy példát az \fdbg nyomkövetõ könyvtár (\ref{fdbg}. fejezet) használatával!
\br
\begin{verbatim}
| ?- fdbg_assign_name(X, x), fdbg_assign_name(Y, y), 
     X in 1..3, Y in 1..2, X #>= Y, fdbg_on, 
     labeling([min], [X,Y]).
% The clp(fd) debugger is switched on
Labeling [1, <x>]: starting in range 1..3.
Labeling [1, <x>]: step: <x> = 1
    <y>#=<1     y = 1..2 -> {1} Constraint exited.
                                                X = 1, Y = 1 ? ;
Labeling [1, <x>]: step: <x> >= 2
    <y>#=<<x>   y = 1..2, x = 2..3  Constraint exited.
    Labeling [6, <y>]: starting in range 1..2.
    Labeling [6, <y>]: step: <y> = 1
        Labeling [8, <x>]: starting in range 2..3.
        Labeling [8, <x>]: step: <x> = 2
                                                X = 2, Y = 1 ? ;
        Labeling [8, <x>]: step: <x> >= 3
                                                X = 3, Y = 1 ? ;
        Labeling [8, <x>]: failed.
    Labeling [6, <y>]: step: <y> >= 2
        Labeling [12, <x>]: starting in range 2..3.
        Labeling [12, <x>]: step: <x> = 2
                                                X = 2, Y = 2 ? ;
        Labeling [12, <x>]: step: <x> >= 3
                                                X = 3, Y = 2 ? ;
        Labeling [12, <x>]: failed.
    Labeling [6, <y>]: failed.
Labeling [1, <x>]: failed.
\end{verbatim}

A keresési fa:

\begin{center}
\epsfig{file=cimke_pelda.eps,width=0.4\textwidth}
\end{center}

Egy másik példa, ezúttal szélsõérték-számításra:

\begin{verbatim}
| ?- _L=[X,Y,Z], domain(_L, 0, 1), V#=Y+Z-X, labeling([minimize(V)], _L).
V = -1, X = 1, Y = 0, Z = 0 ? ;
no
\end{verbatim}

A keresési fa (branch-and-bound algoritmussal):

\begin{center}
\epsfig{file=bb-pelda.eps,width=0.4\textwidth}
\end{center}

A branch-and-bound algoritmus itt elõször megkeresi az elsõ megoldást, majd innentõl
kezdve a további ágak végigjárása során korlátként felveszi azt is, hogy a megoldásnak
kisebbnek kell lennie, mint az eddig megtalált legkisebb. Ha ezzel a feltétellel is
talál újabb megoldást, akkor innentõl kezdve a többi ágon már ezzel az újabb minimummal
dolgozik, egészen addig, amíg be nem járja a teljes keresési teret.
\br
A statisztikai funkciót  és a bal szélsõ ágtól való eltérés korlátozását bemutató példa
(érdemes összevetni az eredményeket a \pageref{kerfak}. oldalon látható keresési
fákkal):

\begin{alltt}
% a Select címkézési mód használatával megkeresi az X in 1..4 korlát összes
% megoldását, és a megoldásokhoz vezetõ utak hosszát As-ben adja vissza
assumptions(Select, As) :-
     X in 1..4, findall(A, labeling([Select, assumptions(A)], [X]), As).

% a Select címkézési mód és D eltérés-korlát használatával megkeresi az
% X in 1..4 korlát összes megoldását, és a megtalált megoldásokat visszaadja
% Xs-ben
lds(Select, D, Xs) :-
     X in 1..4, findall(X, labeling([Select, discrepancy(D)], [X]), Xs).

| ?- assumptions(enum, As).          As = [1,1,1,1] ? ; no
| ?- assumptions(bisect, As).        As = [2,2,2,2] ? ; no
| ?- assumptions(step, As).          As = [1,2,3,3] ? ; no 
                                                                          
| ?- lds(enum, 1, Xs).               Xs = [1,2,3,4] ? ; no 
| ?- lds(bisect, 1, Xs).             Xs = [1,2,3] ? ; no 
| ?- lds(step, 1, Xs).               Xs = [1,2] ? ; no 
\end{alltt}

Látható, hogy \cd{enum} címkézési módnál minden megoldáshoz 1 hosszú út vezet,
mivel egy többszörös választási pontot hoztunk létre. Éppen ezért az a korlátozásunk,
hogy a legbaloldalibb ágtól maximum egyszer térhetünk el, nem jelent semmi pluszt,
mind a négy megoldást meg tudjuk így keresni.
\br
\cd{bisect} címkézésnél minden megoldáshoz egy 2 hosszú út vezet, hiszen az
elsõ választási pontban az \cd{X \#< 3} és \cd{X \#>= 3} korlátok felvétele között
választunk, a második választási pontban pedig a megmaradó 2 méretû tartományokat
felezzük tovább. A legbaloldalibb ágtól való eltérésre vonatkozó korlátunk így nem
találja meg a 4-et, mint megoldást, mert ahhoz elõször az \cd{X \#>= 3} ágat, másodszor
pedig az \cd{X = 4} ágat kéne választanunk, és mindkettõ jobb oldali ág.
\br
\cd{step} címkézésnél az 1-hez, mint megoldáshoz 1 hosszú út vezet, mert az elsõ
választási pontban az \cd{X = 1} és \cd{X \#= 1} korlátok között döntünk. A 2-t így
már csak két lépésben tudjuk megtalálni, a 3-at és a 4-et pedig hasonló módon csak
3-3 lépésben. Mivel a bal oldali út itt mindig az \cd{X} valamely értékre való kötését
jelenti, és csak egyszer léphetünk jobb oldalra, ezért csak az 1-et és a 2-t fogjuk
megtalálni, hiszen a 3-hoz már kétszer, a 4-hez már háromszor kéne jobbra lépnünk.
\br
\label{variable:sel}
Mint azt már néhány oldallal elõbb említettük, a felhasználónak a \cd{labeling/2}
eljárás \cd{variable(Sel)} opcióján keresztül lehetõsége van egy saját változó-kiválasztó
eljárás írására is. Az eljárást \cd{Sel(Vars, Selected, Rest)} alakban hívja meg a rendszer,
ahol \cd{Vars} a még címkézendõ változók/számok listája. \cd{Sel} feladata, hogy
determinisztikusan egyesítse \cd{Selected}-et a következõ címkézendõ \emph{változóval},
\cd{Rest}-et pedig a maradékkal. \cd{Sel} egy tetszõleges meghívható kifejezés lehet,
a három argumentumot a rendszer fûzi \cd{Sel} argumentumainak végére, így a \cd{Sel}
által hivatkozott eljárás akár 3-nál több paraméterrel is rendelkezhet. A példa egy olyan
kiválasztást valósít meg, ahol a felhasználó szabályozhatja, hogy hányadik változót
válasszuk ki a változó-listából.

\begin{verbatim}
% A Vars-beli változók között Sel a Hol-adik, ha a lista teljes hosszát
% 1-nek vesszük (Hol így egy törtszám). Rest a maradék.
valaszt(Hol, Vars, Sel, Rest) :-
        szur(Vars, Szurtek), 
        length(Szurtek, Len), N is integer(Hol*Len),
        nth0(N, Szurtek, Sel, Rest).

% szur(Vk, Szk): A Vk-ban levõ változók listája Szk.
szur([], []).
szur([V|Vk], Szk) :- nonvar(V), !, szur(Vk, Szk).
szur([V|Vk], [V|Szk]) :- szur(Vk, Szk).
\end{verbatim}

\label{value:enum}
Lehetõség van a kiválasztott változó tartományának szûkülését is befolyásolni. Ehhez a
\cd{labeling/2} opció-listájában a \cd{value(Enum)} opciót kell megadnunk. \cd{Enum}-ot
a rendszer \cd{Enum(X, Rest, BB0, BB)} alakban hívja meg, ahol \cd{[X|Rest]} a címkézendõ
változók listája, és ebbõl \cd{X}-et kell az eljárásnak címkéznie, mégpedig
nemdeterminisztikus módon \cd{X} tartományát az összes kívánt módon szûkítve (tehát
a \cd{value(Enum)} a \pageref{labeling:lepesek}. oldalon lévõ lépések közül a
{\bf c.}, {\bf d.} és {\bf e.} lépéseket váltja ki). \cd{BB} és \cd{BB0} értéke számunkra
csak annyiból lényeges, hogy az elsõ választásnál meg kell hívni \cd{first_bound(BB0, BB)}-t,
a másodiknál pedig \cd{later_bound(BB0, BB)}-t a branch-and-bound, illetve LDS módszerek
kiszolgálására. \cd{Enum} egy meghívható kifejezés, a 4 paramétert a rendszer fûzi \cd{Enum}
argumentumlistájának végére. Példaként tekintsünk egy olyan címkézõ eljárást, amely
az értékeket az értéklistában belülrõl kifelé haladva sorolja fel:

\begin{verbatim}
midout(X, _Rest, BB0, BB) :-
        fd_size(X, Size),
        Mid is (Size+1)//2,
        fd_set(X, Set), 
        fdset_to_list(Set, L),
        nth(Mid, L, MidElem),
        (   first_bound(BB0, BB), X = MidElem
        ;   later_bound(BB0, BB), X #\= MidElem
        ).

| ?- X in {1,3,12,19,120}, 
     labeling([value(midout)], [X]).
X = 12 ? ;
X = 3 ? ;
X = 19 ? ;
X = 1 ? ;
X = 120 ? ; no
\end{verbatim}

Végül, a címkézés testreszabásának fontosságát bizonyítandó, nézzük meg az N királynõ
feladat megoldását különféle címkézõ módszerekkel (600 MHz-es Pentium III gépen):

\begin{center}
\enumhead{Összes megoldás keresése}
\begin{tabular}{|l|rr|rr|rr|}
\hline
méret           & \multicolumn{2}{c|}{ n=8}    & \multicolumn{2}{c|}{ n=10}    & \multicolumn{2}{c|}{ n=12}    \\
\hline
megoldások száma       & \multicolumn{2}{c|}{92}    & \multicolumn{2}{c|}{
724}    & \multicolumn{2}{c|}{ 14200}    \\
\hline
címkézés                     & sec & btrk & sec & btrk & sec & btrk \\
\hline
\hline
\cd{[step]}                 & 0.07 & 324 & 1.06 & 5942 & 25.39 & 131K \\ \hline
\cd{[enum]}                 & 0.07 & 324 & 1.03 & 5942 & 24.84 & 131K \\ \hline
\cd{[bisect]}               & 0.07 & 324 & 1.07 & 5942 & 26.04 & 131K \\ \hline \hline
\cd{[enum,min]}             & 0.08 & 462 & 1.31 & 8397 & 33.89 & 202K \\ \hline
\cd{[enum,max]}             & 0.07 & 462 & 1.31 & 8397 & 33.89 & 202K \\ \hline
\cd{[enum,ff]}              & 0.06 & 292 & 0.97 & 4992 & 21.57 & 101K \\ \hline
\cd{[enum,ffc]}             & 0.06 & 292 & 1.04 & 4992 & 23.24 & 101K \\ \hline
\cd{[enum,{\em midvar}\footnotemark[1]]\footnotemark[2]}    & 0.06 & 286 & 0.90 & 4560 & 20.11 &  88K \\ \hline
\end{tabular}
\end{center}

\begin{center}
\enumhead{Elsõ megoldás keresése}
\begin{tabular}{|l|rr|rr|rr|}
\hline
méret           & \multicolumn{2}{c|}{ n=16}    & \multicolumn{2}{c|}{ n=18}    & \multicolumn{2}{c|}{ n=20}    \\
\hline
címkézés                     & sec & btrk & sec & btrk & sec & btrk \\
\hline
\hline
\cd{[enum]}                 & 0.43 & 1833 & 1.76 &  7436 &  9.01 & 37320\\ \hline
\cd{[enum,min]}             & 0.52 & 2095 & 0.87 &  2595 &  1.39 &  3559\\ \hline
\cd{[enum,max]}             & 0.61 & 3182 & 2.68 & 13917 & 16.06 & 83374\\ \hline
\cd{[enum,ff]}              & 0.03 &    7 & 0.05 &    11 &  0.08 &    33\\ \hline
\cd{[enum,ffc]}             & 0.03 &    7 & 0.05 &    11 &  0.09 &    33\\ \hline
\cd{[enum,{\em midvar\footnotemark[1]}]\footnotemark[2]}    & 0.04 &   69 & 0.06 &    57 &  0.15 &   461\\ \hline
\cd{[value(midout)\footnotemark[2]]}        & 0.04 &    3 & 0.05 &     4 &  0.09 &    38\\ \hline
\cd{[value(midout)\footnotemark[2],ffc]}    & 0.04 &   15 & 0.06 &    41 &  0.08 &    20\\ \hline
\end{tabular}
\end{center}

\footnotetext[1]{{\tt{\em midvar} $\equiv$ variable(valaszt(0.5))}.}
\footnotetext[2]{Hatékonyabb statikusan (a címkézés elõtt egyszer) elrendezni a változókat
és az értékeket, \\ lásd az {\tt alt_queens/2} eljárást a \cd{library('clpfd/examples/queens')} állományban.}

%% bele kéne venni a 91. oldalon lévõ részt is???? (szélsõértékek ismételt hívással való
%% elõállítása témakör)

\subsection{Kombinatorikus korlátok}

Az ebben a fejezetben ismertetett globális korlátok az eddigiekhez hasonlóan
nem tükrözhetõek. Minden olyan helyen, ahol a korlátok FD-változót várnak,
írhatunk számértéket is.

\subsubsection{Értékek számolása és különbözõsége}

\medskip

{\bcd{count(Val, List, {\em Relop}, Count)}}

Jelentése: a \cd{Val} egész szám a \cd{List} FD-változó-listában $n$-szer fordul elõ,
és fennáll az  {\it n} \cd{{\em Relop} Count} reláció. Itt \cd{Count} FD változó,
\cd{\em Relop} pedig a hat összehasonlító reláció egyike: \cd{\#=, \#\bs=, \#<} \ldots.
Tartomány-szûkítést biztosít.

\medskip

{\bcd{global_cardinality(Vars, Vals)}}

\cd{Vars} egy FD változókból álló lista, \cd{Vals} pedig  \cd{I-K} alakú párokból
álló lista, ahol \cd{I} egy egész, \cd{K} pedig egy FD változó. Mindegyik \cd{I}
érték csak egyszer fordulhat elõ a \cd{Vals} listában. Jelentése: A \cd{Vars}-beli
FD változók csak a megadott \cd{I} értékeket vehetik fel, és minden egyes \cd{I-K}
párra igaz, hogy a \cd{Vars} listában pontosan \cd{K} darab \cd{I} értékû elem van.
Ha \cd{Vals} vagy \cd{Vars} tömör, és még sok más speciális esetben tartomány-szûkítést
ad.

\medskip

\label{all_distinct}
{\bcd{all\_different(Vs{\em [}, Options{\em ]})\\
      all\_distinct(Vs{\em [}, Options{\em ]})}}

Jelentése: a \cd{Vs} FD változó-lista elemei páronként különbözõek.  
A korlát szûkítési mechanizmusát az \cd{Options} opció-lista szabályozza,
eleme lehet:

\begin{itemize}
\item \cd{consistency(Cons)} --- a szûkítési algoritmust szabályozza. \cd{Cons} lehet:
\begin{description}
\item[\cd{global}] --- tartomány-szûkítõ algoritmus (Regin), durván a
tartományok méretével arányos idejû (alapértelmezés \cd{all\_distinct} esetén)
\item[\cd{bound}] --- intervallum-szûkítõ algoritmus (Mehlhorn), a
változók és értékek számával arányos idejû
\item[\cd{local}] --- a nemegyenlõség páronkénti felvételével azonos
szûkítõ erejû algoritmus, durván a változók számával arányos idejû
(alapértelmezés \cd{all\_different} esetén).
\end{description}

\item \cd{on(On)} --- az ébredést szabályozza. \cd{On} lehet:
\begin{description}
\item[\cd{dom}] --- a változó tartományának bármiféle változásakor
ébreszt (alapértelmezés \cd{all\_distinct} esetén),
\item[{\rm \bf \cd{min}, \cd{max}, {\rm ill.} \cd{minmax}}] ---
a változó tartományának adott ill. bármely határán történõ változáskor ébreszt,
\item[\cd{val}] --- a változó behelyettesítésekor ébreszt csak (alapértelmezés
\cd{all\_different} esetén).
\end{description}

A \cd{consistency(local)} beállításnál nincs értelme \cd{val}-nál
korábban ébreszteni, mert ez a szûkítést nem befolyásolja.
\end{itemize}

A különbözõ ébresztési és szûkítési módok bemutatásához nézzük az alábbi predikátumot:

\begin{verbatim}
pelda(Z, I, On, C) :-
     L = [X,Y,Z], domain(L, 1, 3), 
     all_different(L, [on(On),consistency(C)]), X #\= I, Y #\= I.
\end{verbatim}

\begin{tabular}{ll}
\verb'| ?- pelda(Z, 3, dom, local).'    & $\rightarrow$ \verb'  Z in 1..3 '  \\
\verb'| ?- pelda(Z, 3, min, global).'   & $\rightarrow$ \verb'  Z in 1..3 '  \\
\verb'| ?- pelda(Z, 3, max, bound).'    & $\rightarrow$ \verb'  Z = 3     '  \\
\verb'| ?- pelda(Z, 2, minmax, global).'& $\rightarrow$ \verb'  Z in 1..3 '  \\
\verb'| ?- pelda(Z, 2, dom, bound).'    & $\rightarrow$ \verb'  Z in 1..3 '  \\
\verb'| ?- pelda(Z, 2, dom, global).'   & $\rightarrow$ \verb'  Z = 2     '  \\
\end{tabular}
\br
Látható, hogy csak a harmadik és a hatodik példa jön rá arra, hogy \cd{Z} csak
a második paraméterben megadott érték lehet. Az elsõ és az ötödik példa a \cd{local},
illetve \cd{bound} algoritmus gyengesége miatt nem végzi el a szûkítést, a második
és a negyedik pedig a nem megfelelõ ébresztési feltétel miatt.

\subsubsection{Függvénykapcsolatok és relációk}

{\bcd{element(X, List, Y)}}

Jelentése: \cd{List} \cd{X}-edik eleme \cd{Y} (1-tõl számozva). Itt \cd{X} és \cd{Y}
FD változók, \cd{List} FD változókból álló lista. Az \cd{X} változóra nézve
tartomány-szûkítést, az \cd{Y} és \cd{List} változókra nézve intervallum-szûkítést
biztosít. 

Példák: 

\begin{verbatim}
| ?- element(X, [0,1,2,3,4], Y), X in {2,5}.  % ekvivalens Y #= X-1-gyel
X in {2}\/{5}, Y in 1..4 ?                    % intervallum-konzisztens
| ?- element(X, [0,1,2,3,4], Y), Y in {1,4}.
X in {2}\/{5}, Y in {1}\/{4} ?                % tartomány-konzisztens

% X #= C #<=> B megvalósítása, 1=<{X,C}=<6 esetére
% (C konstans).
beq(X, C, B) :- 
        X in 1..6, call(I #= X+6-C), 
        element(I, [0,0,0,0,0,1,0,0,0,0,0], B).
\end{verbatim}

\medskip
{\bcd{relation(X, Rel, Y)}}

Itt \cd{X} és \cd{Y} FD változók, \cd{Rel} formája: egy lista
{\tt\em Egész-KonstansTartomány} alakú párokból (ahol mindegyik {\tt\em Egész}
csak egyszer fordulhat elõ). Jelentése: \cd{Rel} tartalmaz egy \cd{X-Tart} párt,
ahol \cd{Y} eleme a \cd{Tart}-nak, azaz: \[ \cd{relation(X,H,Y)} \equiv \tuple{\cd{X,Y}}
\in \{\tuple{x,y}|x-\cd{T} \in \cd{H}, y \in \cd{T}\}\] Tetszõleges bináris reláció
definiálására használható, tartomány-szûkítést biztosít. Példa:

\begin{verbatim}
'abs(x-y)>1'(X,Y) :-
        relation(X, [0-(2..5), 1-(3..5), 2-{0,4,5},
                     3-{0,1,5}, 4-(0..2), 5-(0..3)], Y).

| ?- 'abs(x-y)>1'(X,Y), X in 2..3.
Y in (0..1) \/ (4..5) ? ;
no
\end{verbatim}

\medskip
{\bcd{case(Template, Tuples, DAG{\em [}, Options{\em ]})}}

Jelentése: A \cd{Tuples} lista minden elemét illesztve a \cd{Template}
mintára, a \cd{DAG} által leírt reláció fennáll. Az ébresztést és a
szûkítést az \cd{Options} opció-lista szabályozza (hasonló módon, mint
az \cd{all_distinct} esetén, lásd \pageref{all_distinct}. oldal és 
SICStus kézikönyv). Alaphelyzetben minden változásra ébred és
tartomány-szûkítést ad.

A \cd{DAG} csomópontok listája, az elsõ elem a kezdõpont. Egy csomópont
alakja: \cd{node(ID, X, Successors)}. Itt \cd{ID} a csomópont azonosítója
(egész vagy atom), \cd{X} a vizsgálandó változó. Belsõ gráfpont esetén
\cd{Successors} a rákövetkezõ csomópontok listája, elemei \cd{Min..Max)-ID2}
alakúak. Egy ilyen elem jelentése: ha \cd{Min} $\leq$ \cd{X} $\leq$ \cd{Max},
akkor menjünk az \cd{ID2} csomópontra. Végpont esetén \cd{Successors} a
végfeltételek listája, elemei \cd{Min..Max} alakúak, jelentése pedig: ha
valamelyik elem esetén \cd{Min} $\leq$ \cd{X} $\leq$ \cd{Max} fennáll, akkor
a reláció teljesül.
\br
Példaként tekintsük az alábbi gráfot, amely az ,,\cd{X}, \cd{Y} és \cd{Z}
felének egészrésze mind más'' (\([\frac{\cd{X}}{\cd{2}}]\neq[\frac{\cd{Y}}{\cd{2}}],
[\frac{\cd{X}}{\cd{2}}]\neq[\frac{\cd{Z}}{\cd{2}}],
[\frac{\cd{Y}}{\cd{2}}]\neq[\frac{\cd{Z}}{\cd{2}}]\)) relációt írja le a 0..5
tartományon:

\begin{center}\epsfig{file=case.eps,width=0.7\textwidth}\end{center}

Ennek megvalósítása a \cd{case/3} korláttal:

\begin{verbatim}
felemasok(X, Y, Z) :-
   case(f(A,B,C), [f(X,Y,Z)],
        [node([], A, [(0..1)-x0,(2..3)-x1,(4..5)-x2]),
         node(x0, B, [(2..3)-x01,(4..5)-x02]),
         node(x1, B, [(0..1)-x01,(4..5)-x12]),
         node(x2, B, [(0..1)-x02,(2..3)-x12]),
         node(x01,C,[4..5]), node(x02,C,[2..3]), node(x12,C,[0..1])
        ]).
\end{verbatim}

Példa többszörös mintára: \cd{case(T,[A$_1$,$\ldots$],D)$\equiv$case(T,[A$_1$],D),$\ldots$}

\begin{verbatim}
felemasok_vacak(X, Y, Z) :-
    case(A\=B, [X\=Y,X\=Z,Y\=Z],
     [node(root, A, [(0..1)-0,(2..3)-1,(4..5)-2]),
      node(0,B,[2..5]),node(1,B,[0..1,4..5]),node(2, B, [0..3])
     ], [on(val(X)),on(val(Y)),on(val(Y))/*,prune(val(X)), ...*/]).
\end{verbatim}

\subsubsection{Leképezések, gráfok}

{\bcd{sorting(X, I, Y)}}

Az \cd{X} FD-változókból álló lista rendezettje az \cd{Y} FD-változó-lista. Az \cd{I}
FD-változó-lista írja le a rendezéshez szükséges permutációt. Azaz: mindhárom
paraméter azonos ($n$) hosszúságú, \cd{Y} rendezett, \cd{I} az \cd{1..$n$} számok
egy permutációja, és $\forall i \in$ \cd{1..$n$} esetén \cd{X$_i$ =Y$_{\cd{I}_i}$}. 

\medskip

{\bcd{assignment(X, Y{\em [}, Options{\em ]})}}

\cd{X} és \cd{Y} FD változókból alkotott azonos ($n$) hosszúságú listák. Teljesül,
ha \cd{X$_i$} és \cd{Y$_i$} mind az \cd{1..$n$} tartományban vannak és \cd{X$_i$=$j$} 
$\Leftrightarrow$ \cd{Y$_j$=$i$}. Másképpen fogalmazva: \cd{X} egy-egyértelmû
leképezés az \cd{1..$n$} halmazon (az \cd{1..$n$} számok egy permutációja), és
\cd{Y} az \cd{X} inverze.

Az \cd{Options} lista ugyanolyan, mint az \cd{all\_different/[1,2]} korlát
esetében (ld. \pageref{all_distinct}. oldal), az alapértelmezés
\cd{[on(domain),consistency(global)]}.

\medskip

{\bcd{circuit(X)} }

\cd{X} $n$ hosszúságú lista. Igaz, ha minden \cd{X$_i$} az \cd{1..$n$}
tartományba esik, és \cd{X$_1$, X$_{\cd{X}_1}$, X$_{\cd{X}_{\cd{X}_1}}$... }
($n$-szer ismételve) az \cd{1..$n$} számok egy permutációja. Másképp: \cd{X} egy
egyetlen ciklusból álló permutációja az \cd{1..$n$} számoknak.

Gráfokon vett értelmezés: legyen egy $n$ szögpontú irányított gráfunk,
jelöljük a pontokat az \cd{1..$n$} számokkal. Vegyünk fel $n$ db FD-változót,
\cd{X$_i$} tartománya álljon azon $j$ számokból, amelyekre $i$-bõl vezet $j$-be él.
Ekkor \cd{circuit(X)} azt jelenti, hogy az $i$ $\rightarrow$ \cd{X$_i$} élek a
gráf egy Hamilton-körét adják.

\medskip

{\bcd{circuit(X, Y)}}

Ekvivalens a következõvel: \cd{circuit(X), assignment(X, Y)}. Gráfokon értelmezve
megadja a Hamilton-kört és annak az ellenkezõ irányban vett bejárását is.

Példák az \cd{assignment/2} és a \cd{circuit/2} használatára:

\begin{verbatim}
| ?- length(L, 3), domain(L, 1, 3), assignment(L, LInv), L=[2|_], 
     labeling([], L).
L = [2,1,3], LInv = [2,1,3] ? ;
L = [2,3,1], LInv = [3,1,2] ? ;
no
| ?- length(L, 3), domain(L, 1, 3), circuit(L, LInv), L=[2|_].
L = [2,3,1], LInv = [3,1,2] ? ;
no
\end{verbatim}

Kicsit ,,életszagúbb'' példa:

\medskip

\begin{tabular}{cp{0.8\textwidth}}
\begin{tabular}{|c|c|c|}
\hline 1 & 2 & 2 \\ \hline 3 & 1 & 3 \\ \hline 4 & 4 & 1 \\ \hline
\end{tabular} &
\vspace{-1.5\baselineskip}
Adott a bal oldalt látható 3 $\times$ 3-as négyzetrács. Feladat: járjuk be
a rács elemeit a bal felsõ sarokból indulva úgy, hogy minden cellán pontosan
egyszer haladunk át, és $n$-t tartalmazó celláról csak $n+1$-et tartalmazóra
léphetünk (kivéve $n=4$ esetben, innen csak 1-est tartalmazóra). \\
\end{tabular}

\begin{verbatim}
| ?- L=[_1,_2,_3,_4,_5,_6,_7,_8,1], _1=2, _2 in {4,6}, _3=6, 
     _4 in {7,8}, _5 in {2,3}, _6=8, _7=5, _8 in {5,9}, 
     circuit(L).
L = [2,4,6,7,3,8,5,9,1] ? ; no
\end{verbatim}

Az eredmény-listában minden elem megadja, hogy az elemnek megfelelõ cella után
melyik cella következik a körben (a cellákat fentrõl lefelé és balról jobbra
számoztuk be 1-tõl 9-ig).
\br
A \cd{circuit/1} felhasználható az utazó ügynök probléma megoldására is:

\begin{verbatim}
:- module(tsp, [tsp/3]).
:- use_module(library(clpfd)).
:- use_module(library(lists), [append/3]).

tsp(Lab, Successor, Cost) :-
        Successor = [X1,X2,X3,X4,X5,X6,X7],
        Costs = [C1,C2,C3,C4,C5,C6,C7],
        element(X1, [0,205,677,581,461,878,345], C1),
        element(X2, [205,0,882,427,390,1105,540], C2),
        element(X3, [677,882,0,619,316,201,470], C3),
        element(X4, [581,427,619,0,412,592,570], C4),
        element(X5, [461,390,316,412,0,517,190], C5),
        element(X6, [878,1105,201,592,517,0,691], C6),
        element(X7, [345,540,470,570,190,691,0], C7),
        sum(Costs, #=, Cost),
        Predecessor = [Y1,Y2,Y3,Y4,Y5,Y6,Y7],
        Costs2 = [D1,D2,D3,D4,D5,D6,D7],
        element(Y1, [0,205,677,581,461,878,345], D1),
        element(Y2, [205,0,882,427,390,1105,540], D2),
        element(Y3, [677,882,0,619,316,201,470], D3),
        element(Y4, [581,427,619,0,412,592,570], D4),
        element(Y5, [461,390,316,412,0,517,190], D5),
        element(Y6, [878,1105,201,592,517,0,691], D6),
        element(Y7, [345,540,470,570,190,691,0], D7),
        sum(Costs2, #=, Cost),
        circuit(Successor, Predecessor),
        append(Successor, Predecessor, All),
        labeling([minimize(Cost)|Lab], All).

| ?- tsp([ff], Succs, Cost).
Cost = 2276, Succs = [2,4,5,6,7,3,1] ? 
\end{verbatim}

\subsubsection{Ütemezési korlátok}

{\bcd{cumulative(Starts, Durations, Resources, Limit{\em[}, Opts{\em ]})}}

Jelentése: a \cd{Starts} kezdõidõpontokban elkezdett, \cd{Durations} ideig tartó
és \cd{Resources} erõforrásigényû feladatok bármely idõpontban összesített
erõforrásigénye nem haladja meg a \cd{Limit} határt (és fennállnak az opcionális
precedencia korlátok). Az elsõ három argumentum FD változókból álló, egyforma ($n$)
hosszú lista, a negyedik egy FD változó. 

\medskip

{\bcd{serialized(Starts, Durations{\em [}, Opts{\em ]})}}

A \cd{cumulative} speciális esete, ahol az összes erõforrás-igény és a korlát is 1.

\br
Vezessük be a \cd{cumulative($S,D,R,Lim$ \dots )} híváshoz az alábbi jelöléseket:

\begin{quote}
$a = min(S_1,\ldots,S_n)$ {\rm $a$ a kezdõidõpont)} \\
$b = max(S_1+D_1,\ldots,S_n+D_n)$ {\rm $b$ a (végidõpont)}\\
$R_{ij} = R_j$, ha  $S_j \leq i < S_j+D_j$,
        egyébként $R_{ij} = 0$; {\rm $R_{ij}$ (a $j$. feladat erõforrásigénye
        az $i$. idõpontban)}
\end{quote}

Ezekkel a jelölésekkel a korlát jelentése (a precedencia-korlátok nélkül):

\begin{quote}
$R_{i1}+\ldots+R_{in} \leq Lim$ minden $a \leq i < b$ esetén.
\end{quote}

Az \cd{Opts} opciólista a következõ beállításokat tartalmazhatja:

\begin{itemize}
\item \cd{precedences(Ps)} ---
          \cd{Ps} egy lista, amely precedencia korlátokat ír le. Elemei a következõk
          lehetnek (\cd{I} és \cd{J} feladatok sorszámai, \cd{D} egy pozitív
          egész, \cd{Tart} egy  konstans-tartomány):  
\begin{itemize}
\item\cd{d(I,J,D)}, jelentése: $S_\cd{I}+\cd{D} \leq S_\cd{J}$ vagy $S_\cd{J} \leq S_\cd{I}$
(tehát az \cd{I}. és a \cd{J}. feladat közti átállás egy holtidõvel modellezhetõ, és
\cd{D} az \cd{I}. feladat hossza ($D_\cd{I}$) plusz az átállási idõ. Ha azt akarjuk
megadni, hogy egy feladatot elõbb el kell végezni, mint egy másikat, akkor átállási
idõnek \cd{sup}-ot kell megadni.
\item\cd{I-J in Tart}, jelentése: \cd{$S_\cd{I}-S_\cd{J}$ \#= D$_\cd{IJ}$,
D$_\cd{IJ}$ in Tart}. Akkor használatos, ha az \cd{I}. és \cd{J}. feladat között
eltelt idõnek alsó és felsõ korlátja is van.
\end{itemize}

\item \cd{resource(R)} --- speciális ütemezési címkézéshez szükséges opció. \cd{R}-et
          egyesíti egy kifejezéssel, amelyet késõbb átadhatunk az \cd{order\_resource/2}
          eljárásnak, hogy felsoroltassuk a feladatok lehetséges sorrendjeit. Az
          \cd{order_resource/2} eljárásról bõvebben a \pageref{order_resource}. oldalon
          lesz szó.

\item \cd{decomposition(Boolean)} ---
          Ha \cd{Boolean} \cd{true}, akkor minden ébredéskor megpróbálja
          kisebb darabokra bontani a korlátot (pl. ha van két
          át nem lapoló feladathalmazunk, akkor ezeket külön-külön
          kezelhetjük, ami az algoritmusok gyorsabb lefutását
          eredményezheti). Alapértelmezésben ki van kapcsolva.

\item \cd{path\_consistency(Boolean)} ---
          Ha \cd{Boolean} \cd{true}, akkor figyeli a feladatok kezdési
          idõpontja közti különbségek konzisztenciáját. Ez egy olyan redundáns
          korlátra hasonlít, amely minden $i,j$ párra felveszi a
          \cd{SD$_{ij}$ \#= S$_j$ - S$_i$}, és minden $i,j,k$ hármasra a
          \cd{SD$_{ik}$ \#= SD$_{ij}$ + SD$_{jk}$} korlátot. Alapértelmezésben
          ki van kapcsolva.

\item \cd{static\_sets(Boolean)}
          Ha \cd{Boolean} \cd{true}, akkor, ha bizonyos feladatok sorrendje
          ismert, akkor ennek megfelelõen megszorítja azok kezdõ
          idõpontjait. Alapértelmezésben ki van kapcsolva. Például:
\begin{verbatim}
| ?- _S = [S1,S2,S3],  domain(_S, 0, 9), (SS = false ; SS = true),
     serialized(_S, [5,2,7], [static_sets(SS),
                              precedences([d(3,1,sup), d(3,2,sup)])]).
SS=false, S1 in 0..4, S2 in(0..2)\/(5..7), S3 in 5..9 ? ;
SS=true,  S1 in 0..4, S2 in(0..2)\/(5..7), S3 in 7..9 ? ;
no
\end{verbatim}

\item \cd{edge\_finder(Boolean)}
          Ha \cd{Boolean} \cd{true}, akkor megpróbálja kikövetkeztetni az egyes
          feladatok sorrendjét. Alapértelmezésben ki van kapcsolva. Példa:
\begin{verbatim}
| ?- _S = [S1,S2,S3], domain(_S, 0, 9),
      serialized(_S, [8,2,2], [edge_finder(true)]).
S1 in 4..9, S2 in 0..7, S3 in 0..7 ? ;
no
\end{verbatim}

\item \cd{bounds_only(Boolean)}
          Ha \cd{Boolean} \cd{true}, akkor a korlát az $S_i$ változóknak
          csak a határait szûkíti, a belsejüket nem. Alapértelmezésben be van kapcsolva.

\end{itemize}

\medskip

{\bcd{cumulatives(Tasks, Machines{\em [}, Options{\em ]})}} \\
Több erõforrást (gépet) igénylõ feladatok ütemezése (lásd SICStus kézikönyv).
\br
Példaként tekintsünk egy olyan ütemezési feladatot, ahol a rendelkezésre álló
erõforrások száma 13, az erõforrásigények és idõtartamok pedig az alábbi táblázat
szerint alakulnak:

\begin{center}
\begin{tabular}{|l|r|r|r|r|r|r|r|}
\hline
Tevékenység               & t1   & t2    & t3   & t4   & t5   & t6   & t7 \\ 
\hline                                                         
Idõtartam                 & 16   & 6     & 13   & 7    & 5    & 18   & 4 \\  
Erõforrásigény            & 2    & 9     & 3    & 7    &10    & 1    &11\\   
\hline
\hline
Egy megoldás              &0--16 &16--22 &9--22 &9--16 &4--9  &4--22 &0--4\\
\hline
\end{tabular}
\end{center}

\begin{verbatim}
% A fenti ütemezési feladatban a tevékenységek kezdõidõpontjait
% az Ss lista tartalmazza, a legkorábbi végidõpont az End.
schedule(Ss, End) :-
        length(Ss, 7),
        Ds = [16, 6,13, 7, 5,18, 4],
        Rs = [ 2, 9, 3, 7,10, 1,11],
        domain(Ss, 0, 30),
        End in 0.. 50,
        after(Ss, Ds, End),
        cumulative(Ss, Ds, Rs, 13),
        labeling([ff,minimize(End)], [End|Ss]).

% after(Ss, Ds, E): Az E idõpont az Ss kezdetû Ds idõtartamú 
% tevékenységek mindegyikének befejezése után van.
after([], [], _).
after([S|Ss], [D|Ds], E) :- E #>= S+D, after(Ss, Ds, E).
\end{verbatim}

\begin{minipage}[c]{0.40\textwidth}
\begin{alltt}
| ?- schedule(Ss, End).

Ss = [0,16,9,9,4,4,0], 
End = 22 ? ;  
no
\end{alltt}
\end{minipage}
\hspace{0.10\textwidth}
\parbox[c]{0.45\textwidth}{
\epsfig{file=sched3.eps,width=0.45\textwidth}}

Példa precedencia-korlátra:

\begin{alltt}
| ?- _S = [S1,S2], domain(_S,0,9), S1 #< S2, {\em{}% a két külön korlát}
     serialized(_S, [4,4], []).              {\em{}% nem jól szûkít:}
        S1 in 0..8, S2 in 1..9 ? ;  no

| ?- _S = [S1,S2], domain(_S,0,9), Opts=[precedences([d(2,1,sup)],
     serialized(_S, [4,4], Opts)]). {\em{}% ^^ \(\equiv\) S1 #< S2}
        S1 in 0..5, S2 in 4..9 ? ;  no
\end{alltt}
\label{order_resource}
{\bcd{order_resource(Options, Resource)}}

Igaz, ha a \cd{Resource} által leírt feladatok elrendezhetõk valamilyen
sorrendbe. Ezeket az elrendezéseket felsorolja. A \cd{Resource} argumentumot a
fenti ütemezõ eljárásoktól kaphatjuk meg az ütemezõ eljárás opció-listájába
helyezett \cd{resource(Resource)} elemmel. Az \cd{order_resource/2} opció-listája
a következõ dolgokat tartalmazhatja (mindegyik csoportból legfeljebb egyet,
alapértelmezés: \cd{[first,est]}):

\begin{itemize}
\item stratégia
     \begin{itemize}
     \item \cd{first} Mindig olyan feladatot választunk ki, amelyet az összes
                       többi elé helyezhetünk.
     \item \cd{last} Mindig olyan feladatot választunk ki, amelyet az összes
                       többi után helyezhetünk.
     \end{itemize}
\item tulajdonság: \cd{first} stratégia esetén az adott tulajdonság
     minimumát, \cd{last} esetén a maximumát tekintjük az összes feladatra
     nézve.
     \begin{itemize}
     \item \cd{est} legkorábbi lehetséges kezdési idõ
     \item \cd{lst} legkésõbbi lehetséges kezdési idõ
     \item \cd{ect} legkorábbi lehetséges befejezési idõ
     \item \cd{lct} legkésõbbi lehetséges befejezési idõ
     \end{itemize}
\end{itemize}

Példa:

\begin{verbatim}
| ?- _S=[S1,S2,S3], domain(_S, 0, 9),
     serialized(_S, [5,2,7],
                [precedences([d(3,1,sup), d(3,2,sup)]),
                 resource(_R)]), order_resource([],_R).
S1 in 0..2, S2 in 5..7, S3 in 7..9 ? ;
S1 in 2..4, S2 in 0..2, S3 in 7..9 ? ;
no
\end{verbatim}

Látható, hogy az \cd{order_resource/2} csak a lehetséges elrendezésekre vonatkozóan
címkéz, de az egyes elrendezéseken belül a változók értékeit ,,függõben'' hagyja.

\subsubsection{Diszjunkt szakaszok és téglalapok}

{\bcd{disjoint1(Lines{\em [}, Options{\em ]})}}

Jelentése: A \cd{Lines} által megadott intervallumok diszjunktak. A \cd{Lines} lista
elemei $F(S_j,D_j)$ vagy $F(S_j,D_j,T_j)$ alakú kifejezések listája, ahol $S_j$ és
$D_j$ $j$. szakasz kezdõpontját és hosszát megadó változók. $F$ tetszõleges funktor,
$T_j$ egy atom vagy egy egész, amely a szakasz típusát definiálja (alapértelmezése 0).
Az \cd{Options} lista a következõ dolgokat tartalmazhatja (a \cd{Boolean} változók
alapértelmezése \cd{false}):

\begin{itemize}
\item \cd{decomposition(Boolean)}
          Ha \cd{Boolean} \cd{true}, akkor minden ébredéskor megpróbálja kisebb
          darabokra bontatni a korlátot.

\item \cd{global(Boolean)}
          Ha \cd{Boolean} \cd{true}, akkor egy redundáns algoritmust használ a
          jobb szûkítés érdekében. Példa:

\begin{verbatim}
| ?- domain([S1,S2,S3], 0, 9), (G = false ; G = true),
     disjoint1([S1-8,S2-2,S3-2], [global(G)]).
       G = false, S1 in 0..9, S2 in 0..9, S3 in 0..9 ? ;
       G = true,  S1 in 4..9, S2 in 0..7, S3 in 0..7 ? 
\end{verbatim}

\item \cd{wrap(Min,Max)}
          A szakaszok nem egy egyenesen, hanem egy körön helyezkednek el,
          ahol a \cd{Min} és \cd{Max} pozíciók egybeesnek (\cd{Min} and
          \cd{Max} egészek kell, hogy legyenek). Ez az opció a \cd{Min..(Max-1)}
          intervallumba kényszeríti a kezdõpontokat.

\item \cd{margin(T1,T2,D)}
          Bármely \cd{T1} típusú vonal végpontja legalább \cd{D} távolságra lesz
          bármely \cd{T2} típusú vonal kezdõpontjától, ha \cd{D} egész.
          Ha \cd{D} nem egész, akkor a \cd{sup} atomnak kell lennie, ekkor
          minden \cd{T2} típusú vonalnak elõrébb kell lennie, mint bármely
          \cd{T1} típusú vonal.
\end{itemize}

{\bcd{disjoint2(Rectangles{\em [}, Options{\em ]})}}

     Jelentése: A \cd{Rectangles} által megadott téglalapok nem metszik
     egymást. A \cd{Rectangles} lista elemei $F(S_{j1},D_{j1},S_{j2},D_{j2})$
     vagy $F(S_{j1},D_{j1},S_{j2},D_{j2},T_j)$ alakú kifejezések. Itt
     $S_{j1}$ és $D_{j1}$ a $j$. téglalap X irányú kezdõpontját és hosszát
     jelölõ változók, $S_{j2}$ és $D_{j2}$ ezek Y irányú megfelelõi,
     $F$ tetszõleges funktor,  $T_j$ egy egész vagy atom, amely a
     téglalap típusát jelöli (alapértelmezése 0).

Az \cd{Options} lista a következõ dolgokat tartalmazhatja (a \cd{Boolean} változók
alapértelmezése \cd{false}):

\begin{itemize}
\item \cd{decomposition(Boolean)}
          Mint \cd{disjoint1/2}.

\item \cd{global(Boolean)}
          Mint \cd{disjoint1/2}.

\item \cd{wrap(Min1,Max1,Min2,Max2)}
          \cd{Min1} és \cd{Max1} egész számok vagy rendre az \cd{inf} vagy
          \cd{sup} atom. Ha egészek, akkor a téglalapok egy olyan henger
          palástján helyezkednek el, amely az X irányban fordul körbe, ahol
          a \cd{Min1} és \cd{Max1} pozíciók egybeesnek. Ez az opció a
          \cd{Min1..(Max1-1)} intervallumba kényszeríti az $S_{j1}$ változókat.
          \cd{Min2} és \cd{Max2} ugyanezt jelenti Y irányban. Ha mind a négy
          paraméter egész, akkor a téglalapok egy tóruszon helyezkednek el.

\item \cd{margin(T1,T2,D1,D2)}
          Ez az opció minimális távolságokat ad meg, \cd{D1} az X,
          \cd{D2} az Y irányban bármely \cd{T1} típusú téglalap vég- és bármely \cd{T2}
          típusú téglalap kezdõpontja között. \cd{D1} és \cd{D2} egészek vagy a
          \cd{sup} atom. \cd{sup} azt jelenti, hogy a \cd{T2} típusú téglalapokat
          a \cd{T1} típusú téglalapok elé kell helyezni a megfelelõ irányban.

\item \cd{synchronization(Boolean)}:  Speciális esetben redundáns korlátot
          vesz fel (lásd SICStus kézikönyv).
\end{itemize}

Példa: helyezzünk el három diszjunkt téglalapot úgy, hogy $(x,y)$ bal alsó sarkuk
az $0 \leq x \leq 2, 0 \leq y \leq 1$ téglalapban legyen. A méretek ($x \times y$
sorrendben): 1 $\times$ 3, 2 $\times$ 2, 3 $\times$ 3. Az 1 $\times$ 3-as téglalap
$x$ koordinátája nem lehet 2.

\begin{verbatim}
| ?- domain([X1,X2,X3], 0, 2), domain([Y1,Y2,Y3], 0, 1), X1 #\= 2,
     disjoint2([r(X1,3,Y1,1),r(X2,2,Y2,2),r(X3,3,0,3)]).
X1 in 0..1, Y1 = 0,   X2 = 0, Y2 = 1,   X3 = 2, Y3 = 1 ?
\end{verbatim}

\subsection{Felhasználói korlátok definiálása}

A SICStus Prolog kétféle lehetõséget kínál a \clpfd modul korlátainak
felhasználói korlátokkal való bõvítésére: a \emph{globális korlát}okat és
az \emph{FD predikátum}okat. A \emph{globális korlát}ok tetszõleges (nem korlátos)
számú változót tartalmazó korlátok definiálására alkalmasak. A korlátok
mûködését teljesen általános Prolog kódként adhatjuk meg, beleértve az
ébresztési feltételeket és a befejezés módját is. A globális korlátok
reifikációja (tükrözése) azonban nem támogatott. Az \emph{FD predikátumok}
ezzel szemben csak rögzített számú változót tartalmazó korlátok leírására
alkalmasak, viszont itt a reifikáció is támogatott, és az ébresztési
feltételek meghatározása automatikus. Az FD predikátumokban a programozó
úgynevezett \emph{indexikálisok} segítségével írja le a szûkítési, illetve
levezethetõségi feltételeket. Az indexikálisok nyelve egy speciális, halmazértékû
funkcionális nyelv a tartományokkal való mûveletek végzésére. Az alábbi
Prolog kód egy példa egy FD predikátumra:

\begin{alltt}
% Az X+Y #= T korlát (intervallum szûkítéssel)
'x+y=t'(X,Y,T) +:  
        X in min(T) - max(Y)..max(T) - min(Y),
        Y in min(T) - max(X)..max(T) - min(X),
        T in min(X) + min(Y)..max(X) + max(Y).
\end{alltt}

Az indexikális nyelv bõvebb elemzése az \ref{fdpred}. fejezetben olvasható.

\subsubsection{Globális korlátok}

\label{globalis}

Mint azt már említettük, a globális korlátot egy külön Prolog eljárásként
kell megírni, amelyben az \cd{fd\_global/3} eljárással indul el a korlát
tényleges végrehajtása. Az \cd{fd\_global/3} paraméterezése:
\br
{\bcd{fd\_global(Constraint, State, Susp)}}\\
Elindítja \cd{Constraint} végrehajtását \cd{State} kezdõállapottal és
\cd{Susp} ébresztési feltételekkel. \cd{Constraint} egy tetszõleges Prolog
struktúra lehet, azonban célszerû a korlát nevével megegyezõre választani,
már csak azért is, mert ha a \cd{clpfd:full_answer} bekapcsolásával kérjük
a le nem futott démonok megjelenítését, akkor a Prolog a \cd{Constraint}-ben
megadott nevet fogja kiírni.
\br
A Prolog lehetõséget biztosít arra, hogy a globális korlát az ébresztések
között megõrizzen bizonyos állapotinformációkat. Ez az állapotinformáció
is tetszõleges Prolog struktúra lehet, a kezdõértékét pedig a \cd{State}
paraméterrel tudjuk beállítani.
\br
A korlát indításakor az \cd{fd\_global/3} harmadik paraméterében
meg kell adni egy ébresztési listát, amely elõírja, hogy mely változók
milyen tartomány-változásakor kell felébreszteni a korlátot. A lista elemei
a következõk lehetnek:
\begin{itemize}
\item \cd{dom(X)} --- az \cd{X} változó tartományának bármely
változásakor
\item \cd{min(X)} --- az \cd{X} változó alsó határának változásakor
\item \cd{max(X)} --- az \cd{X} változó felsõ határának változásakor
\item \cd{minmax(X)} --- az \cd{X} változó alsó vagy felsõ határának
változásakor
\item \cd{val(X)} --- az \cd{X} változó behelyettesítésekor
\end{itemize}

Fontos, hogy a korlát \emph{nem} tudja majd, hogy melyik változójának milyen
változása miatt ébresztik fel. Ráadásul ha több változás történik, a korlát
akkor is csak egyszer fog felébredni, éppen ezért nagyon fontos, hogy a
korlát minden lehetséges tartomány-változásra megfelelõen reagáljon anélkül,
hogy tudná, hogy pontosan melyik változó változása ébresztette fel õt.
\br
Az \cd{fd\_global/3} meghívásakor és minden ébredéskor a rendszer elvégzi a
felhasználó által megadott szûkítéseket. Ezeket a szûkítéseket a
\cd{clpfd:dispatch\_global/4} többállományos (\cd{multifile}) kampó-eljárás
kibõvítésével lehet megadni.
\br
{\bcd{clpfd:dispatch\_global(Constraint, State, NewState, Actions)}}\\
Ennek az eljárásnak a törzse definiálja a \cd{Constraint} korlát ébredésekor
végrehajtandó teendõket és állapot-változásokat. A \cd{Constraint} paraméterben
ugyanaz a struktúra fog megjelenni, mint amit az \cd{fd\_global/3} elsõ
paraméterében átadtunk. \cd{State} tartalmazza az ébredéskor fennálló állapotot,
\cd{NewState}-et pedig nekünk kell majd kitölteni az új állapottal. A végrehajtandó
szûkítéseket \emph{tilos} a kampó-eljárás belsejében végrehajtani, helyette ezeket
az \cd{Actions} listában kell átadnunk, és ott kell jeleznünk a korlát sikeres
lefutását vagy meghiúsulását is. Alapértelmezésben a korlát démona az eljárás
lefutása után visszaalszik.
\br
Az \cd{Actions} lista az alábbi elemekbõl állhat (a sorrend nem számít):

\begin{itemize}
\item \cd{exit} ill. \cd{fail} --- a korlát sikeresen ill. sikertelenül lefutott
\item \cd{X=V}, \cd{X in R}, \cd{X in\_set S} --- az adott szûkítést kérjük végrehajtani
(ez is okozhat meghiúsulást)
\item \cd{call(Module:Goal)} --- az adott hívást kérjük végrehajtani. A
\cd{Module:} modul-kvalifikáció kötelezõ!
\end{itemize}

Mivel a \cd{dispatch_global/4} eljárás a többi \cd{multifile} eljáráshoz hasonlóan
interpretáltan fut, ezért a futás gyorsítása érdekében célszerû a \cd{dispatch_global}
eljárások törzsébe csak egyetlen klózt írni, ami az általunk írt korlátkezelõ eljárásra
mutat (mivel az már betöltéskor le fog fordulni, és így gyorsabb lesz a futás).
\br
Az alábbi példa az \cd{X \#=< Y} korlát megvalósítása globális korlátként:

\begin{verbatim}
:- multifile clpfd:dispatch_global/4.
:- discontiguous clpfd:dispatch_global/4.   % nem folytonos eljárás

% X #=< Y, globális korlátként megvalósítva.
lseq(X, Y) :-
        % lseq(X,Y) globális démon indul, kezdõállapot: void.
        % Ébredés: X alsó és Y felsõ határának változásakor.
        fd_global(lseq(X,Y), void, [min(X),max(Y)]).

clpfd:dispatch_global(lseq(X,Y), St, St, Actions) :-
        dispatch_lseq(X, Y, Actions).

dispatch_lseq(X, Y, Actions) :-
        fd_min(X, MinX), fd_max(X, MaxX),
        fd_min(Y, MinY), fd_max(Y, MaxY),
        (   number(MaxX), number(MinY), MaxX =< MinY
            % buzgóbb, mint X#=<Y, mert az csak X vagy Y
            % behelyettesítésekor fut le.
        ->  Actions = [exit]
        ;   Actions = [X in inf..MaxY,Y in MinX..sup]
        ).
\end{verbatim}

A fenti korlát mûködése igen egyszerû. Elõször meghatározzuk \cd{X} és \cd{Y} tartományainak
szélsõ határait a megfelelõ változókba. Ezek után ha \cd{MaxX} és \cd{MinY} is szám
(tehát nem \cd{inf} vagy \cd{sup}), valamint \cd{MaxX} kisebb vagy egyenlõ, mint \cd{MinY},
akkor befejezzük a mûködésünket, ellenkezõ esetben \cd{X}-et az \cd{inf..MaxY}, \cd{Y}-t
a \cd{MinX..sup} intervallumra szûkítjük, és újra elalszunk. Ha az elõzõ két szûkítés
valamelyike meghiúsulna, akkor a Prolog automatikusan gondoskodik arról, hogy visszalépés
következzen be.
\br
Újabb példa, ezúttal az \cd{S = sign(X)} (\cd{X} elõjele \cd{S}) korlátra:

\begin{alltt}
% X elõjele S, globális korlátként megvalósítva.
sign(X, S) :-
        S in -1..1,
        fd_global(sign(X,S), void, [minmax(X),minmax(S)]).
        % Ébredés: X és S alsó és felsõ határának változásakor.

clpfd:dispatch_global(sign(X,S), St, St, Actions) :-
        fd_min(X, MinX0), sign_of(MinX0, MinS),
        fd_max(X, MaxX0), sign_of(MaxX0, MaxS),
        fd_min(S, MinS0), sign_min_max(MinS0, MinX, _),
        fd_max(S, MaxS0), sign_min_max(MaxS0, _, MaxX),
        Actions = [X in MinX..MaxX, S in MinS..MaxS|Exit],
        (   max(MinS0,MinS)=:=min(MaxS0,MaxS) -> Exit = [exit]
        ;   Exit = []
        ).

% sign_of(X, S): X egész vagy végtelen érték elõjele S
sign_of(inf, S) :- !, S = -1.
sign_of(sup, S) :- !, S = 1.
sign_of(X, S) :- S is sign(X).

% sign_min_max(S, Min, Max): \(sign(x)=\cd{S} \Leftrightarrow x \in \cd{Min..Max}\)
sign_min_max(-1, inf, -1).
sign_min_max(0, 0, 0).
sign_min_max(1, 1, sup).
\end{alltt}

A reifikáció megvalósítása globális korláttal:

\begin{verbatim}
% X #=< Y #<=> B, globális korlátként megvalósítva.
lseq_reif(X, Y, B) :-
        B in 0..1, fd_global(lseq_reif(X,Y,B), void,       
                             [minmax(X),minmax(Y),val(B)]).

clpfd:dispatch_global(lseq_reif(X,Y, B), St, St, Actions) :-
        fd_min(X, MinX), fd_max(X, MaxX),
        fd_min(Y, MinY), fd_max(Y, MaxY),
        (   fdset_interval(_, MaxX, MinY)   % MaxX =< MinY
        ->  Actions = [exit,B=1]  
        ;   empty_interval(MinX, MaxY)      % MaxY < MinX
        ->  Actions = [exit,B=0]
        ;   B == 1 -> Actions = [exit, call(user:lseq(X,Y))]
        ;   B == 0 -> Actions = [exit, call(user:less(Y,X))]
        ;   Actions = []
        ).
\end{verbatim}

Ehhez hasonló trükkökkel természetesen tetszõleges globális korlátot átírhatunk
olyan alakba, amely egy 0-1 értékû változóban tükrözi az igazságértékét, de
ez nem ,,tiszta'' reifikáció. Mindössze annyi ilyenkor a teendõnk, hogy meghatározzuk
azokat a feltételeket, amelyekbõl kiderül, hogy a korlát, illetve a negáltja levezethetõ,
és ezen feltételek teljesülése esetén az igazságértéket \cd{0}-ra, illetve \cd{1}-re
kell szûkítenünk. Ugyanakkor arra is figyelni kell, hogy ha az igazságérték kerül
behelyettesítésre, akkor a korlátot, illetve a negáltját ezúttal reifikáció nélkül
kell felvennünk a tárba.
\br
Valósítsuk meg globális korlátként a mágikus sorozatok példájában már használt
\cd{pontosan/3} korlátot! (Emlékeztetõül: \cd{pontosan(I, L, E)} $\Leftrightarrow$
az \cd{I} elem \cd{L}-ben \cd{E}-szer fordul elõ)

\begin{alltt}
% Az Xs listában az I szám pontosan N-szer fordul elõ.
% N és az Xs lista elemei FD változók vagy számok lehetnek.
exactly(I, Xs, N) :-
    dom_susps(Xs, Susp),
    length(Xs, Len), N in 0..Len,
    fd_global(exactly(I,Xs,N), Xs/0, [minmax(N)|Susp]).
    % Állapot: L/Min ahol L az Xs-bõl az I-vel azonos ill.
    % biztosan nem-egyenlõ elemek esetleges kiszûrésével áll
    % elõ, és Min a kiszûrt I-k száma.

% dom_susps(Xs, Susp): Susp dom(X)-ek listája, minden X \(\in\) Xs-re.
dom_susps([], []).
dom_susps([X|Xs], [dom(X)|Susp]) :- 
    dom_susps(Xs, Susp).

clpfd:dispatch_global(exactly(I,_,N), Xs0/Min0, Xs/Min, Actions) :-
    ex_filter(Xs0, Xs, Min0, Min, I),
    length(Xs, Len), Max is Min+Len,
    fd_min(N, MinN), fd_max(N, MaxN),
    (   MaxN =:= Min -> Actions = [exit,N=MaxN|Ps],
        ex_neq(Xs, I, Ps)            % Ps = \(\{x\) in_set \bs\{I\}\( | x\in\) Xs\(\}\)
    ;   MinN =:= Max -> Actions = [exit,N=MinN|Ps],
        ex_eq(Xs, I, Ps)             % Ps = \(\{x\) in_set  \{I\}\( | x\in\) Xs\(\}\)
    ;   Actions = [N in Min..Max]
    ).

% ex_filter(Xs, Ys, N0, N, I): Xs-bõl az I-vel azonos ill. attól
% biztosan különbözõ elemek elhagyásával kapjuk Ys-t,
% N-N0 a kiszûrt I-k száma.
ex_filter([], [], N, N, _).
ex_filter([X|Xs], Ys, N0, N, I) :-
    X==I, !, N1 is N0+1, ex_filter(Xs, Ys, N1, N, I).
ex_filter([X|Xs], Ys0, N0, N, I) :-
    fd_set(X, Set), fdset_member(I, Set), !,   % X még lehet I
    Ys0 = [X|Ys], ex_filter(Xs, Ys, N0, N, I).
ex_filter([_X|Xs], Ys, N0, N, I) :-            % X már nem lehet I
    ex_filter(Xs, Ys, N0, N, I).

% A Ps lista elemei `X in_set S', \(\forall\) X \(\in\) Xs-re, S az \bs\{I\} FD halmaz.
ex_neq(Xs, I, Ps) :- 
    fdset_singleton(Set0, I), fdset_complement(Set0, Set), 
    eq_all(Xs, Set, Ps).

% A Ps lista elemei `X in_set S', \(\forall\) X \(\in\) Xs-re, S az \{I\} FD halmaz.
ex_eq(Xs, I, Ps) :- 
    fdset_singleton(Set, I), eq_all(Xs, Set, Ps).

% eq_all(Xs, S, Ps): Ps `X in_set S'-ek listája, minden X \(\in\) Xs-re.
eq_all([], _, []).
eq_all([X|Xs], Set, [X in_set Set|Ps]) :- 
    eq_all(Xs, Set, Ps).


| ?- exactly(5, [A,B,C], N), N #=< 1, A=5.
A = 5, B in (inf..4)\bs/(6..sup), C in (inf..4)\bs/(6..sup), N = 1 ?
| ?- exactly(5, [A,B,C], N), A in 1..2, B in 3..4, N #>= 1.
A in 1..2, B in 3..4, C = 5, N = 1 ?
| ?- _L=[A,B,C], domain(_L,1,3), A #=< B, B #< C, exactly(3, _L, N).
A in 1..2, B in 1..2, C in 2..3, N in 0..1 ?
\end{alltt}

A SICStus 3.8.6-nál és a régebbi verzióknál a fenti megvalósítás kapcsán egy érdekes
hibával találhatjuk magunkat szemközt:

\begin{verbatim}
| ?- L = [N,1], N in {0,2}, exactly(0, L, N).
L = [0,1], N = 0 ? ;
no
\end{verbatim}

Amint látható, a kapott megoldás hibás, hiszen a \cd{[0,1]} listában a \cd{0} elem
nem 0-szor fordul elõ, tehát az \cd{exactly(0, L, N)} korlát nem áll fenn. A probléma
általánosan a következõképpen fogalmazható meg:

\begin{quote}
Legyen \cd{c(X,Y)} egy globális korlát, amely \cd{[dom(X),dom(Y)]}
ébresztésû. Tegyük fel, hogy \cd{X} tartománya változik, és ennek hatására
a korlát szûkíti \cd{Y} tartományát. Kérdés: ébredjen-e fel ettõl újra a
korlát?
\end{quote}

A SICStus fejlesztõi úgy döntöttek, hogy ilyen esetben a korlát ne ébredjen fel újra.
Emiatt egy globális korláttal szemben támasztanunk kell egy olyan elvárást, hogy az
\emph{idempotens} legyen: ha meghívjuk, elvégezzük az akció-lista feldolgozását,
majd azonnal újra meghívjuk, akkor a második hívás már biztosan ne váltson ki további
szûkítéseket (tehát ne legyen érdemes újra meghívni). Formálisan: $dg(dg(s))=dg(s)$,
ahol $dg$ a \cd{dispatch_global/4} eljárásnak a tárra gyakorolt hatását jelöli.
\br
Jelen példánkban a korlátunk megvalósítása nem teljesíti az idempotencia feltételét,
mivel az \cd{L} lista elsõ eleme \cd{N}, és ezáltal \cd{N}-en keresztül az \cd{exactly/3}
második és harmadik paramétere ,,össze van kapcsolva''. A SICStus a 3.8.7. verzió óta
figyeli az összekapcsolt változókat, és ha ilyet talál, akkor automatikusan feltételezi
a $dg$ függvényrõl, hogy az nem idempotens, ezért újra és újra meghívja az \cd{exactly/3}
korlát démonát egészen addig, amíg van szûkítés. Így a második meghívás alkalmával
már kiderül a fent megtalált megoldásról, hogy az hibás.

\subsubsection{FD predikátumok}

\label{fdpred}

Az FD predikátumok segítségével egy korlát levezethetõségi és szûkítési szabályait
írhatjuk le egy halmazértékû funkcionális nyelv alkalmazásával. Egy FD predikátum
formailag hasonlít egy hagyományos Prolog predikátumhoz, de más a jelentése, és
szigorúbb formai szabályokkal is szembe kell néznünk.
\br
Az FD predikátumok mindig 1..4 klózból állnak, és mindnek más a ,,nyakjele''. A
\cd{+:} nyakjelû klózt kötelezõ megírni, a \cd{-:}, \cd{+?} és \cd{-?} nyakjelûek
opcionálisak, akkor van rájuk szükség, ha reifikálható korlátot szeretnénk írni.
A klózok törzse úgynevezett \emph{indexikális}ok gyûjteményébõl áll, az egyes
indexikálisokat vesszõvel kell egymástól elválasztani, de ez esetben a vesszõ
\emph{nem} konjunkciót jelent, a hagyományos Prolog predikátumokkal ellentétben.
A \cd{+:} és \cd{-:} nyakjelû klózok \emph{szûkítõ} (\emph{mondó}, \emph{tell})
indexikálisokból állnak, és azt írják le, hogy az adott korlát, illetve a negáltja
hogyan szûkíti a korlát-tárat. A \cd{+?} és \cd{-?} nyakjelû klózok egyetlen
\emph{kérdezõ} (\emph{ask}) indexikálist tartalmaznak, amely azt írja le, hogy
a korlát, illetve a negáltja mely feltétel teljesülése esetén vezethetõ le a
tárból. Az FD klózok fejében az argumentumok kötelezõen csak változók lehetnek,
és a törzsben is csak ezek a változók szerepelhetnek. Példaként tekintsük az
\cd{X \#=< Y} korlát FD predikátum változatát:

\begin{verbatim}
'x=<y'(X,Y) +:                 % Az X =< Y korlát szûkítései.
        X in inf..max(Y),      % X szûkítendõ az inf..max(Y),
        Y in min(X)..sup.      % Y a min(X)..sup intervallumra.

'x=<y'(X,Y) -:                 % Az X =< Y korlát negáltjának,
        X in (min(Y)+1)..sup,  % azaz az X > Y korlátnak a
        Y in inf..(max(X)-1).  % szûkítései.

'x=<y'(X,Y) +?                 % Ha X tartománya része az 
        X in inf..min(Y).      % inf..min(Y) intervallumnak, 
                               % akkor X =< Y levezethetõ.

'x=<y'(X,Y) -?                 % Ha X tartománya része a 
        X in (max(Y)+1)..sup.  % (max(Y)+1)..sup intervallumnak, 
                               % akkor X > Y levezethetõ.
\end{verbatim}

A fenti példából már láthatjuk, hogy az összes indexikális \cd{{\em Változó} in {\em
TKif}} alakú, ahol a \cd{{\em TKif}} tartománykifejezés tartalmazza a
\cd{{\em Változó}}-tól különbözõ \emph{összes} fejváltozót. Ha olyan indexikálist
írunk, amelyre ez utóbbi feltétel nem teljesül, akkor igen nagy a valószínûsége,
hogy az indexikális hibásan fog mûködni (erre a \pageref{hibas_indexikalis}. oldalon
látunk is majd egy példát). A \cd{\em{TKif}} tartománykifejezés (\emph{range})
egy (parciális) halmazfüggvényt ír le, azaz a benne szereplõ változók tartományának
függvényében egy újabb tartományt állít elõ. Például a \cd{min(X)..sup} kifejezés
az \cd{X} alsó határának függvényében állít elõ egy tartományt, ha \cd{X}-rõl azt
tudjuk, hogy az \cd{1..10} intervallumban van benne, akkor \cd{min(X)..sup} = \cd{1..sup}
fog teljesülni. A \cd{{\em Változó} in {\em TKif}} alakú kifejezés \cd{\em Változó}
értékét a \cd{\em TKif} tartománykifejezés által elõállított halmazra szûkíti (bizonyos
feltételek fennállása esetén, ld. késõbb). 

Formálisan: az \cd{X in {\em R}(Y,Z,\ldots)} indexikális jelentése a következõ
reláció:

\[
Rel(R) =  \{ \tuple{x,y,z, \ldots} | x \in \parbox{0.6em}{\tt\em R}(\{y\},\{z\}, \ldots)\}
\]

Más szóval ha az \cd{\em R}-beli változóknak egyelemû a tartománya, akkor az
\cd{\em R} tartománykifejezés értéke \emph{pontosan} az adott relációt kielégítõ \cd{X}
értékek halmaza lesz (ld. még a pont-szûkítés definícióját, \pageref{pontszukites}. oldal).
\br
{\bf Az FD predikátumok alapszabálya:} az egy FD-klózon belül lévõ indexikálisok
jelentésének (azaz az általuk definiált relációnak) azonosnak kell lennie! Ennek oka
az úgynevezett ,,\emph{társasház-elv}'': az FD predikátum kiértékelésére a Prolog
\emph{bármelyik} indexikálist felhasználhatja! Gyakorlásképp nézzük meg, hogy az elõzõ
példa FD-klózaiban teljesül-e ez az alapszabály:

\begin{alltt}
'x=<y'(X, Y) +: 
    X in inf..max(Y), % \(\{\tuple{x,y}|x\in{}\cd{inf..max(\{}y\cd{\})}\} \equiv \{\tuple{x,y}|x\in{}(-\infty,y]\} \equiv \{\tuple{x,y}|x\leq{}y\}\)
    Y in min(X)..sup. % \(\{\tuple{x,y}|y\in{}\cd{min(\{}x\cd{\})..sup}\} \equiv \{\tuple{x,y}|y\in{}[x,+\infty)\} \equiv \{\tuple{x,y}|y\geq{}x\}\)
\end{alltt}

Mivel $x \leq y$ és $y \geq x$ ekvivalensek, ezért itt a társasház-elv teljesül.
\br
Most definiálni fogjuk a tartománykifejezések pontos szintaktikáját. Bevezetjük az
alábbi jelöléseket ($s$ továbbra is egy adott korlát-tárat fog jelenteni):

\begin{description}
\item[$X$] egy korlát-változó, tartománya \domx{X}. \vspace*{-1ex}
\item[$T$] egy számkifejezés ({\em term}), amelynek jelentése 
egy egész szám vagy egy végtelen érték, ezt \valx{T}-sel jelöljük. 
(Végtelen érték csak \cd{$T_1$..$T_2$}-ben lehet.) \vspace*{-1ex}
\item[$R$] egy tartománykifejezés ({\em range}), amelynek jelentése
egy számhalmaz, amit \setx{R}-sel jelölünk.
\end{description}

A tartománykifejezéseket alkotó elemi kifejezések és operátorok összefoglalva az
alábbi táblázatban láthatóak:

\begin{center}{\tt
\begin{tabular}{|p{15em}|@{\hspace*{3.5em}}p{21.5em}|}
\hline
{\rm\bf Szintaxis}                &   \hspace*{-3em}{\rm\bf Szemantika}            \\
\hline
\rule{0ex}{3ex}$T$ $\Longrightarrow$             &   \hspace*{-3em}\valx{T} =     \\
\ \ \ \ \ \ {\em integer}         &   {\em integer} {\rm értéke}                  \\
\ \ |\ \ \ inf                    &   \(-\infty\)                                 \\
\ \ |\ \ \ sup                    &   \(+\infty\)                                 \\
\ \ |\ \ \ $X$                    &   {\rm \(x\) feltéve, hogy \domx{X}\(=\{x\}\).  
                                      Egyébként az indexikális felfüggesztõdik       
                                      (,,pucér'' változó esete).}                 \\
\ \ |\ \ \ card($X$)              &   $\left| \domxm{X} \right|$ {\rm(a tartomány elemszáma)}\\
\ \ |\ \ \ min($X$)               &   \(\min(\domxm{X})\) {\rm(a tartomány alsó határa)} \\
\ \ |\ \ \ max($X$)               &   \(\max(\domxm{X})\) {\rm(a tartomány felsõ határa)} \\
\ \ |\ \ \ $T_1$ + $T_2$          &   $\valxm{T_1} + \valxm{T_2}$ \\
\ \ |\ \ \ $T_1$ - $T_2$          &   $\valxm{T_1} - \valxm{T_2}$ \\
\ \ |\ \ \ $T_1$ * $T_2$          &   $\valxm{T_1} * \valxm{T_2}$ \\
\ \ |\ \ \ $T_1$ mod $T_2$        &   $\valxm{T_1} \bmod \valxm{T_2}$             \\
\ \ |\ \ \ - $T_1$                &   $- \valxm{T_1}$ \\
\ \ |\ \ \ $T_1$ /> $T_2$         &   $\left\lceil\valxm{T_1}/\valxm{T_2}\right\rceil$
                                      {\rm (felfelé kerekített osztás)}\\
\ \ |\ \ \ $T_1$ /< $T_2$         &   $\left\lfloor\valxm{T_1}/\valxm{T_2}\right\rfloor$
                                      {\rm (lefelé kerekített osztás)}\\[1ex]
\hline
\rule{0ex}{3ex}$R$ $\Longrightarrow$  &   \hspace*{-3em}\setx{R} =                \\%[1ex]
\ \ \ \ \ \ \{$T_1$,$\ldots$,$T_n$\}   &   $\{\valxm{T_1},\ldots,\valxm{T_n}\}$    \\
\ \ |\ \ \ dom($X$)               &   \domx{X}                                     \\
\ \ |\ \ \ $T_1$..$T_2$           &   $[\valxm{T_1},\valxm{T_2}]$ 
                                      {\rm (intervallum)}           \\
\ \ |\ \ \ $R_1$/\bs{}$R_2$       &   $\setxm{R_1}\cap\setxm{R_2}$  {\rm (metszet)}\\
\ \ |\ \ \ $R_1$\bs/{}$R_2$       &   $\setxm{R_1}\cup\setxm{R_2}$  {\rm (unió)}\\
\ \ |\ \ \ \bs{}$R_1$             &   $\setminus\setxm{R_1}$   {\rm (komplementer halmaz) }                  \\
\ \ |\ \ \ - $R_1$                &   $\{ -x | x \in \setxm{R_1} \}$ {\rm (pontonkénti negáció) }                    \\
\ \ |\ \ \ $R_1$ + $R_2$          &   $\{ x+y | x \in \setxm{R_1}, y \in \setxm{R_2} \}$ {\rm (pont. összeg)}                \\                                     
\ \ |\ \ \ $R_1$ + $T_2$          &   $\{ x+t | x \in \setxm{R_1}, t = \valxm{T_2} \}$ \\
\ \ |\ \ \ $R_1$ - $R_2$          &   $\{ x-y | x \in \setxm{R_1}, y \in \setxm{R_2} \}$ {\rm (p. különbség)}                \\                                     
\ \ |\ \ \ $R_1$ - $T_2$          &   $\{ x-t | x \in \setxm{R_1}, t = \valxm{T_2} \}$ \\
\ \ |\ \ \ $T_1$ - $R_2$          &   $\{ t-y | t = \valxm{T_1}, y \in \setxm{R_2} \}$ \\
\ \ |\ \ \ $R_1$ mod $R_2$        &   $\{ x \bmod y | x \in \setxm{R_1}, y \in \setxm{R_2} \}$ {\rm (p. modulo)}                     \\                                     
\ \ |\ \ \ $R_1$ mod $T_2$        &   $\{ x \bmod t | x \in \setxm{R_1}, t = \valxm{T_2} \}$ \\
\ \ |\ \ \ unionof($X$,$R_1$,$R_2$) &   {\rm unió-kifejezés, ld. \pageref{unio:ind}. oldal }                          \\
\ \ |\ \ \ switch($T$,$MapList$)   &   {\rm kapcsoló-kifejezés, ld. \pageref{kapcs:ind}. oldal}                      \\
\ \ |\ \ \ $R_1$\ ?\ $R_2$          &   {\rm feltételes kifejezés, ld. \pageref{felt:ind}. oldal }              \\[1ex]
\hline
\end{tabular}
}\end{center}

Az ilyen kifejezésekben szereplõ összeadás, kivonás, szorzás, osztás, modulus és
ellentett mûveletek mindegyike \emph{pontonkénti} mûveletvégzés. Ez azt takarja,
hogy a mûveletet végrehajtjuk a két operandusból a Descartes-szorzat segítségével
kapott párokra, majd az eredményekbõl egy újabb halmazt képezünk. Például vegyük
az alábbi korlátot:

\begin{alltt}
f(X,Y) +: Y in 5 - dom(X).  {\em%} \(\{ \makebox[2em]{5-x} | \makebox[0.8em]{x}\in{}\cd{dom(X)} \}\) 
\end{alltt}

A fenti korlát az \cd{Y \#= 5-X} relációt valósítja meg, tartományszûkítõ módon:

\begin{verbatim}
| ?- X in {1, 3, 5}, f(X,Y).
Y in{0}\/{2}\/{4} ?
\end{verbatim}

Itt a korlát belsejében az \cd{Y in 5 - dom(X)} hívás során minden $x \in$ \domx{X}-re
végrehajtódik az $y = 5-x$ kivonás, majd ezeket az $y$-okat egy halmazba rakva kapjuk
\domx{Y}-t.
\br
A korábban \cd{plusz/3} néven hivatkozott tartományszûkítõ összegkorlát FD predikátummal
való megvalósítása:

\begin{alltt}
| 'x+y=t tsz'(X, Y, T) +:
        X in dom(T) - dom(Y), {\em%} \(\{ \makebox[2em]{t-y} | \makebox[0.8em]{t}\in{}\cd{dom(T)}, \makebox[0.8em]{y}\in{}\cd{dom(Y)} \}\) 
        Y in dom(T) - dom(X), {\em%} \(\{ \makebox[2em]{t-y} | \makebox[0.8em]{t}\in{}\cd{dom(T)}, \makebox[0.8em]{x}\in{}\cd{dom(X)} \}\) 
        T in dom(X) + dom(Y). {\em%} \(\{ \makebox[2em]{x+y} | \makebox[0.8em]{x}\in{}\cd{dom(X)}, \makebox[0.8em]{y}\in{}\cd{dom(Y)} \}\) 

| ?- _X in \{10,20\}, _Y in \{0,5\}, _X+_Y #= Z.
Z in 10..25 ?
| ?- _X in \{10,20\}, _Y in \{0,5\}, 'x+y=t tsz'(_X, _Y, Z).
Z in\{10\}\bs/\{15\}\bs/\{20\}\bs/\{25\} ?
\end{alltt}

Példa ,,pucér'' (indexikálisban önmagában álló) változóra:

\begin{alltt}
f(X,Y,I) +: Y in \bs\{X,X+I,X-I\}.
% hasonló az N királynõ feladat no_threat/3 korlátjához, ld. \pageref{no:threat}. oldal

| ?- X in \{3, 5\}, Y in 1..5, f(X, Y, 2), X = 3.
Y in \{2\}\bs\{4\} ?
\end{alltt}

Pucér változó használata esetén az indexikális végrehajtása felfüggesztõdik addig,
amíg a pucér változók be nem helyettesítõdnek. Végül egy példa bonyolultabb számkifejezés
indexikálisos megvalósítására:

\begin{alltt}
| 'ax+c=t'(A,X,C,T) +:  % feltétel: A > 0
        X in (min(T) - C) /> A .. (max(T) - C) /< A,
        T in min(X)*A + C      ..  max(X)*A + C.

| ?- 'ax+c=t'(2,X,1,T), T in 0..4.
X in 0..1, T in 1..3 ?
\end{alltt}

\subsubsection{Indexikálisok monotonitása}

Az imént említettük azt is, hogy a \cd{{\em Változó} in {\em TKif}} alakú indexikális
\cd{\em Változó} értékét csak bizonyos feltételek teljesülése mellett szûkíti
a \cd{\em TKif} tartománykifejezés által elõállított halmazra. Most tisztázni fogjuk,
hogy mik is ezek a bizonyos feltételek. Tekintsük az alábbi két FD predikátumot:

\begin{alltt}
f(X, Y) +: Y in min(X)..sup.

| ?- X in 5..10, f(X, Y).
X in 5..10, Y in 5..sup?

f(X, Y) +: Y in max(X)..sup.

| ?- X in 5..10, f(X, Y).
X in 5..10, Y in inf..sup?
\end{alltt}

A két FD predikátum ránézésre nagyjából megegyezik, ha \cd{X} tartománya egyelemû
lenne, akkor mindkettõ az \cd{Y \#>= X} korláttal ekvivalens jelentésû lenne. A második
esetben azonban a Prolog mégsem hajlandó szûkíteni, ugyanis az \cd{Y in 10..sup}
szûkítést kéne végrehajtania, majd \cd{X} tartományának késõbbi szûkülésekor \cd{Y}
tartományát \emph{bõvítenie} kellene, ami nem lehetséges. Például ha a késõbbiekben
kiderülne, hogy \cd{X in 6..7}, akkor \cd{Y}-nak a \cd{7..sup} tartományra kéne
bõvülnie.
\br
Az általános megfogalmazáshoz vezessünk be néhány újabb fogalmat:
\br
\definicio egy $R$ tartománykifejezés egy $s$ tárban \emph{kiértékelhetõ}, ha az
$R$-ben elõforduló összes ,,pucér'' változó tartománya az $s$ tárban
egyelemû (be van helyettesítve). A továbbiakban csak kiértékelhetõ
tartománykifejezésekkel foglalkozunk.
\br
\definicio egy $s$ tárnak \emph{pontosítás}a $s'$ ($s' \subseteq s$), ha minden
$X$ változóra $D(X,s') \subseteq D(X,s)$ (azaz $s'$ szûkítéssel állhat elõ $s$-bõl).
\br
\definicio egy $R$ tartománykifejezés egy $s$ tárra nézve \emph{monoton}, ha
minden $s' \subseteq s$ esetén $S(R,s') \subseteq S(R,s)$, azaz a tár
szûkítésekor a kifejezés értéke is szûkül.
\br
\definicio egy $R$ tartománykifejezés egy $s$ tárra nézve \emph{antimonoton}, ha
minden $s' \subseteq s$ esetén $S(R,s') \supseteq S(R,s)$.
\br
\definicio $R$ $s$-ben konstans, ha monoton és antimonoton (azaz $s$ szûkülésekor
már nem változik).
\br
\definicio egy indexikálist monotonnak, antimonotonnak, ill. konstansnak nevezünk,
ha a tartománykifejezése monoton, antimonoton, ill. konstans. 

\enum{Példák}{
\item \cd{min(X)..max(Y)} egy tetszõleges tárban monoton.
\item \cd{max(X)..max(Y)} monoton minden olyan tárban, ahol \cd{X} behelyettesített,
és antimonoton, ahol \cd{Y} behelyettesített.
\item \cd{card(X)..Y} kiértékelhetõ, ha \cd{Y} behelyettesített, és ilyenkor antimonoton.
\item \cd{(min(X)..sup) \bs/ (0..sup)} egy tetszõleges tárban monoton,
és konstans minden olyan tárban, ahol \cd{min(X) >= 0}.
}

\tetel ha egy ,,\cd{$X$ in $R$}'' indexikális monoton egy $s$ tárban, akkor
$X$ értéktartománya az $S(R,s)$ tartománnyal szûkíthetõ.
\br
{\bf Bizonyítás} (vázlat): Tegyük fel, hogy $x_0 \in D(X,s)$ egy tetszõleges olyan
érték, amelyhez találhatók olyan $y_0 \in D(Y,s$), $z_0 \in D(Z,s)$, \ldots értékek, hogy 
$\tuple{x_0,y_0,z_0,\ldots}$ kielégíti az indexikális által definiált relációt. Azaz

\[ \tuple{x_0,y_0,z_0,\ldots} \in Rel(R) \Leftrightarrow x_0 \in S(R, s'), 
s'= \{Y~\cd{in}~\{y_0\},Z~\cd{in}~\{z_0\},\ldots\} \]

Itt $s' \subseteq s$, hiszen $y_0 \in D(Y,s$), $z_0 \in D(Z,s)$,
\ldots. A monotonitás miatt $S(R, s)
\supseteq S(R, s') \ni x_0$. Így tehát $S(R, s)$ tartalmazza az összes, a
reláció által az $s$ tárban megengedett értéket, ezért ezzel a halmazzal
való szûkítés jogos.
\br
A \clpfd rendszer egy indexikálisról a következõ irányelvek alapján dönti el, hogy
az monoton-e vagy sem:

\begin{itemize}
\item Egy számkifejezésrõl egyszerûen megállapítható, hogy a tár
szûkülésekor nõ, csökken, vagy konstans-e (kivéve \cd{$T_1$ mod $T_2$}, itt
várunk, míg $T_2$ konstans lesz).
\item Tartománykifejezések esetén:
\begin{itemize}
\item \cd{$T_1$..$T_2$} monoton, ha $T_1$ csökken és $T_2$ nõ, antimonoton,
 ha $T_1$ nõ és $T_2$ csökken.
\item \cd{dom($X$)} mindig monoton.
\item A metszet és unió mûveletek eredménye (anti)monoton, ha mindkét
operandusuk az, a komplemensképzés mûvelete megfordítja a monotonitást.
\item A pontonként végzett mûveletek megõrzik az (anti)monotonitást (ehhez a
$T_i$ operandus konstans kell legyen, pl.\ \cd{dom(X)+card(Y)}$\leadsto$\cd{dom(X)+1}).
\end{itemize}
\item Az (anti)monotonitás eldöntésekor a rendszer csak a változók behelyettesítettségét
vizsgálja, pl. a \cd{(min(X)..sup) \bs/ (0..sup)} kifejezést csak akkor tekinti
konstansnak, ha \cd{X} behelyettesített.
\end{itemize}

\subsubsection{Szûkítõ indexikálisok feldolgozási lépései}

Egy \cd{X in R} szûkítõ indexikális feldolgozása mindig a végrehajthatóság vizsgálatával
kezdõdik: ha \cd{R}-ben behelyettesítetlen (,,pucér'') változó van, vagy \cd{R}-rõl a
rendszer nem látja azonnal, hogy monoton, akkor felfüggeszti a végrehajtását addig, amíg
ezek a feltételek nem teljesülnek. Ezek után meghatározza az indexikálisból képzõdõ démon
aktiválási feltételeit az egyes \cd{R}-beli változókra nézve, mégpedig az alábbiak
szerint (\cd{Y} az \cd{R}-ben elõforduló változók egyike):

\begin{itemize}
        \item \cd{dom(Y), card(Y)} környezetben elõforduló \cd{Y} változó esetén az
        indexikális a változó tartományának bármilyen módosulásakor
        aktiválandó; 
        \item \cd{min(Y)} környezetben -- alsó határ változásakor
        aktiválandó;
         \item
        \cd{max(Y)} környezetben-- felsõ határ változásakor aktiválandó.
\end{itemize}

A szûkítés menete a következõek szerint történik: ha $D(X,s)$ és $S(R,s)$ diszjunktak,
akkor visszalépés következik be, egyébként a tárat az $X\ \cd{in}\ S(R,s)$ korláttal
szûkítjük (erõsítjük), azaz $D(X,s):= D(X,s) \cap S(R,s)$. A démon akkor fejezi be
mûködését, ha az \cd{R} tartománykifejezés konstanssá válik (például azért, mert
minden \cd{R}-beli változó behelyettesítõdik). Ekkor $Rel(\cd{R})$ garantáltan fennáll,
ezért \emph{az indexikálist tartalmazó korlát} levezethetõ, ilyenkor viszont a társasház-elv
alapján hatékonysági okokból a korlát \emph{összes} indexikálisa befejezi a mûködését.
\br
Az indexikálisok feldolgozási lépéseit néhány példán keresztül is bemutatjuk:

\begin{alltt}
'x=<y'(X, Y) +:
        X in inf..max(Y),     {\em{}% (ind1)}
        Y in min(X)..sup.     {\em{}% (ind2)}
\end{alltt}

\enum{Az \cd{\em (ind1)} indexikális végrehajtási lépései}{
\item Végrehajthatóság vizsgálata: nincs benne pucér változó, monoton, tehát végrehajtható
\item Aktiválás: \cd{Y} felsõ határának változásakor.
\item Szûkítés: \cd{X} tartományát elmetsszük az \cd{inf..max(Y)}
        tartománnyal, azaz \cd{X} felsõ határát az \cd{Y}-éra állítjuk,
        ha az utóbbi a kisebb.
\item Befejezés: amikor \cd{Y} behelyettesítõdik, akkor \cd{\em (ind1)}
        konstanssá válik. Ekkor {\bf mindkét} indexikális --- \cd{\em (ind1)}
        és \cd{\em (ind2)} is ---befejezi mûködését.  }

Egy másik korlát, kicsit kevésbé részletesen:

\begin{alltt}
'abs(x-y)>=c'(X, Y, C) +:
        X in (inf .. max(Y)-C) \bs/ (min(Y)+C .. sup),
        % vagy:  X in \bs (max(Y)-C+1 .. min(Y)+C-1),
        Y in (inf .. max(X)-C) \bs/ (min(X)+C .. sup).

| ?- 'abs(x-y)>=c'(X,Y,5), X in 0..6.
X in 0..6, Y in(inf..1)\bs/(5..sup) ?
| ?- 'abs(x-y)>=c'(X,Y,5), X in 0..9.
X in 0..9, Y in inf..sup ?
\end{alltt}

A \cd{no_threat/3} korlát (ld. N királynõ feladat, \pageref{no:threat}. oldal) kicsit
erõsebb indexikálisos megvalósítása:

\begin{alltt}
no_threat_2(X, Y, I) +:
        X in \bs\{Y,Y+I,Y-I\}, Y in \bs\{X,X+I,X-I\}.

| ?- no_threat_2(X, Y, 2), Y in 1..5, X=3.
X = 3, Y in \{2\}\bs/\{4\} ?
| ?- no_threat_2(X, Y, 2), Y in 1..5, X in \{3,5\}.
X in\{3\}\bs/\{5\}, Y in 1..5 ?
\end{alltt}

Érdemes megfigyelni, hogy a második példában nincs szûkítés annak ellenére, hogy \cd{Y}
sem 3, sem 5 nem lehet. Azonban mivel az \cd{Y}-hoz tartozó indexikálisban \cd{X}
pucéron szerepel, de még nem teljesen behelyettesített, ezért a teljes indexikális
felfüggesztõdik.
\br
Végül nézzünk egy példát arra az esetre, amikor a társasház-elv nem érvényesül, és
ezért az FD predikátum hibásan mûködik:

\label{hibas_indexikalis}
\begin{alltt}
'x=<y=<z rossz'(X, Y, Z) +:
        Y in min(X)..max(Z),    {\em%} \(\{ \tuple{x,y,z} | x \leq y \leq z\}\)
        Z in min(Y).. sup,      {\em%} \(\{ \tuple{x,y,z} |      y \leq z\}\)
        X in inf..max(Y).       {\em%} \(\{ \tuple{x,y,z} | x \leq y     \}\)

| ?- 'x=<y=<z rossz'(15, 5, Z).
Z in 5..sup ?
\end{alltt}

A korlát felvételekor egyedül a második indexikális tud aktiválódni (mivel \cd{Y} és \cd{X}
már eleve konstans), és ez leszûkíti \cd{Z}-t az \cd{5..sup} intervallumra anélkül, hogy
figyelembe venné, hogy a korlát a \cd{15} $\not\leq$ \cd{5} feltétel miatt eleve nem állhat
fenn. A javításhoz meg kell ismerkednünk azzal a három tartománykifejezéssel is, amelyekrõl
eddig még nem esett szó.

\subsubsection{Bonyolultabb tartománykifejezések}

\label{unio:ind}
\enumhead{Unió-kifejezés: \cd{unionof(X, H, T)}}

Egy \cd{unionof(X, H, T)} kifejezésben \cd{X} változó, \cd{H} és \cd{T}
tartománykifejezések. Kiértékelése egy $s$ tárban: legyen \cd{H} értéke
az $s$ tárban $S(\cd{H},s) = \{x_1, \ldots, x_n\}$ (ha $S(H,s)$ végtelen,
a kiértékelést felfüggesztjük). Képezzük a $T_i$ kifejezéseket úgy, hogy
\cd{T}-ben \cd{X} helyébe $x_i$-t írjuk. Ekkor az unió-kifejezés értéke
a $S(T_1,s), \ldots, S(T_n,s)$ halmazok uniója. Képlettel:
\[
        S(\cd{unionof(X,H,T)}, s) = \bigcup \{S(\cd{T}, (s \wedge \cd{X =}
        x)) | x \in D(\cd{H}, s)\}
\]

Egy unió-kifejezés kiértékelésének ideje/tárigénye arányos a \cd{H}
tartomány méretével!
\br
A \cd{no_threat/3} (ld. N királynõ feladat, \pageref{no:threat}. oldal) maximálisan
szûkítõ, de egyáltalán nem hatékony megvalósítása:

\begin{alltt}
no_threat_3(X, Y, I) +:
        X in unionof(B, dom(Y), \bs\{B,B+I,B-I\}),
        Y in unionof(B, dom(X), \bs\{B,B+I,B-I\}).

| ?- no_threat_3(X, Y, 2), Y in 1..5, X in \{3,5\}.
X in \{3,5\}, Y in \{1,2,4\} ?
\end{alltt}

\label{kapcs:ind}
\enumhead{Kapcsoló-kifejezés: \cd{switch(T, MapList)}}
\cd{T} egy számkifejezés, \cd{MapList} pedig \cd{{\em integer}-Range}
alakú párokból álló lista, ahol az \cd{\em integer} értékek mind
különböznek (\cd{Range} egy tartománykifejezés). Jelöljük $K$-val \valx{T}-t
(ha \cd{T} nem kiértékelhetõ, az indexikálist felfüggesztjük).
Ha \cd{MapList} tartalmaz egy $K-R$ párt, akkor a kapcsoló-kifejezés értéke
$S(R,s)$ lesz, egyébként az üres halmaz lesz az értéke. Példa:

\begin{verbatim}
% Ha I páros, Z = X, egyébként Z = Y. Vár míg I értéket nem kap.
p(I, X, Y, Z) +:   Z in switch(I mod 2, [0-dom(X),1-dom(Y)]).

p2(I, X, Y, Z) +:  % ugyanaz mint p/4, de nem vár.
    Z in unionof(J, dom(I) mod 2, switch(J, [0-dom(X),1-dom(Y)])).
\end{verbatim}

Egy \cd{relation/3} kapcsolat megvalósítható egy \cd{unionof-switch} szerkezettel:

\begin{alltt}
% relation(X, [0-\{1\},1-\{0,2\},2-\{1,3\},3-\{2\}], Y) \(\Leftrightarrow |x-y|=1 x,y\in[0,3]\)
absdiff1(X, Y) +:
  X in unionof(B,dom(Y),switch(B,[0-\{1\},1-\{0,2\},2-\{1,3\},3-\{2\}])),
  Y in unionof(B,dom(X),switch(B,[0-\{1\},1-\{0,2\},2-\{1,3\},3-\{2\}])).
\end{alltt}

Példa: az \cd{Y in \{0,2,4\}} tárban \cd{absdiff1} elsõ indexikálisának
kiértékelése a következõ (jelöljük \cd{MAPL}-lel a
\cd{[0-\{1\},1-\{0,2\},2-\{1,3\},3-\{2\}]} listát):

\begin{verbatim}
X in unionof(B,{0,2,4},switch(B,MAPL)) =
     switch(0,MAPL) \/ switch(2,MAPL) \/ switch(4,MAPL) =
     {1}            \/ {1,3}          \/ {}             = {1,3}
\end{verbatim}

\label{felt:ind}
\enumhead{Feltételes kifejezés: \cd{Felt ? Tart}}

\cd{Felt} és \cd{Tart} tartománykifejezések. Ha \setx{\cd{Felt}} üres halmaz, akkor a
feltételes kifejezés értéke is üres halmaz, egyébként pedig azonos \setx{\cd{Tart}}
értékével. Példák:

\begin{verbatim}
% X in 4..8 #<=> B.
'x in 4..8<=>b'(X, B) +:
        B in (dom(X)/\(4..8)) ? {1} \/ (dom(X)/\ \(4..8)) ? {0},
        X in (dom(B)/\{1}) ? (4..8) \/ (dom(B)/\{0}) ? \(4..8).
\end{verbatim}

A feltételes kifejezés használatával már meg tudjuk fogalmazni az \cd{'x=<y=<z'/3}
korlátunk helyes szûkítési feltételeit:

\begin{alltt}
'x=<y=<z'(X, Y, Z) +:
        Y in min(X)..max(Z),
        Z in ((inf..max(Y)) /\bs dom(X)) ? (min(Y)..sup),  % (*)
             {\em% ha} max(Y) \(\geq\) min(X){\em akkor} min(Y)..sup{\em egyébként} \{\}
        X in ((min(Y)..sup) /\bs dom(Z)) ? (inf..max(Y)).
\end{alltt}

A \cd{(*)} indexikális jobboldalának kiértékelése az elõzõleg problematikus esetben
(\cd{X = 15, Y = 5}):

\begin{alltt}
X = 15, Y = 5 \(\Longrightarrow\) (inf..5)/\bs\{15\} ? (5..sup) = \{\} ? (5..sup) = \{\}
X = 15, Y in 5..30 \(\Longrightarrow\) (inf..30)/\bs\{15\} ? 5..sup = {15} ? 5..sup = 5..sup
\end{alltt}

A feltételes kifejezés a kiértékelés késleltetésére is használható, ha 
\cd{(Felt?(inf..sup) \bs/ Tart)} alakban használjuk. Ezen tartománykifejezés
értéke \setx{\cd{Tart}}, ha \setx{\cd{Felt}} üres, egyébként \cd{inf..sup}. Az ilyen
szerkezetekben \cd{Tart} értékét a rendszer nem értékeli ki, amíg \cd{Felt} nem üres.
Példa:

\begin{verbatim}
% Maximálisan szûkít, kicsit kevésbé lassú
no_threat_4(X, Y, I) +:
    X in (4..card(Y))?(inf..sup) \/ unionof(B,dom(Y),\{B,B+I,B-I}), % (**)
    Y in (4..card(X))?(inf..sup) \/ unionof(B,dom(X),\{B,B+I,B-I}).
\end{verbatim}

Ez a \cd{no_threat/3} korlát egy olyan megvalósítása, amely csak abban az esetben
használja az egyik változó esetében az \cd{unionof} szerkezetet, ha a másik változó
halmazának számossága már 4-nél kisebb. A \cd{(**)} indexikális jobb oldalának
kiértékelése (\cd{I = 1}):

\begin{verbatim}
Y in 5..8 ---> (4..4)?(inf..sup) \/ unionof(...) = inf..sup

Y in 5..7 ---> (4..3)?(inf..sup) \/ unionof(B,5..7,\{B,B+1,B-1}) =
                {}?(inf..sup) \/ unionof(B,5..7,\{B,B+1,B-1}) =
                {} \/ \{5,6,4} \/ \{6,7,5} \/ \{7,8,6} = \{6}
\end{verbatim}

\subsubsection{Reifikálható FD predikátumok}

Egy reifikálható FD predikátumban általában mind a négy nyakjelû klóz szerepel. Ha
valamelyiket elhagyjuk, akkor az ahhoz tartozó szûkítés, illetve levezethetõség-vizsgálat
elmarad. Emlékeztetõül: a \cd{+:} és \cd{-:} nyakjelû klózok \emph{szûkítõ}
(\emph{mondó}, \emph{tell}) indexikálisokból állnak, és azt írják le, hogy az adott
korlát, illetve a negáltja hogyan szûkíti a korlát-tárat. A \cd{+?} és \cd{-?} nyakjelû
klózok egyetlen \emph{kérdezõ} (\emph{ask}) indexikálist tartalmaznak, amely azt
írja le, hogy a korlát, illetve a negáltja mely feltétel teljesülése esetén vezethetõ
le a tárból. A kérdezõ klózban egy \cd{X in R} kérdezõ indexikális valójában a
\cd{dom(X)} $\subseteq$ \cd{R} feltételt fejezi ki, mint az FD predikátum (vagy
negáltja) levezethetõségi feltételét. Például az \cd{X \#\bs= Y} korlát esetén:

\begin{verbatim}
'x\\=y'(X,Y) +:        % 1. a korlátot szûkítõ indexikálisok
        X in \{Y},
        Y in \{X}.

'x\\=y'(X,Y) -:        % 2. a negáltját szûkítõ indexikálisok
        X in dom(Y),
        Y in dom(X).

'x\\=y'(X,Y) +?        % 3. a levezethetõséget kérdezõ
        X in \dom(Y).  % indexikális

'x\\=y'(X,Y) -?        % 4. a negált levezethetõségét kérdezõ
        X in {Y}.      % indexikális (itt felesleges, az okot
                       % lásd késõbb)
\end{verbatim}

Egy \cd{X \#\bs= Y \#<=> B} reifikáció ezek után a következõképpen megy végbe: a
3. klóz folyamatosan figyeli, hogy \cd{X} és \cd{Y} tartományai diszjunktak-e
(\cd{dom(X)} $\subseteq$ \cd{\bs dom(Y)}), és ha ez teljesül, akkor \cd{B}-be
1-et helyettesít. Ugyanakkor a 4. klóz figyeli, hogy \cd{X=Y} igaz-e (\cd{dom(X)}
$\subseteq$ \cd{\{Y\}}), és ha igen, akkor \cd{B}-be 0-t helyettesít. Közben
egy külön démon figyeli, hogy \cd{B} behelyettesítõdik-e, ha igen, és \cd{B=1},
akkor elindítja az 1. klózbeli indexikálisokat. \cd{B=0} esetben a 2. klóz
indexikálisai indulnak el.

\subsubsection{Kérdezõ indexikálisok feldolgozási lépései}

A kérdezõ indexikálisokra másfajta feldolgozási szabályok érvényesek, mint a
szûkítõ indexikálisokra. A legfontosabb különbség, hogy egy kérdezõ indexikális
végrehajtását mindaddig felfüggesztjük, amíg kiértékelhetõ és \emph{antimonoton}
nem lesz (ellentétben a szûkítõ indexikálisokkal, ahol a monotonitás volt a
feltétel). Az ébresztési feltételek a szûkítõ indexikálisokhoz hasonlóak
(\cd{Y} az \cd{X in R} kifejezés esetén egy \cd{R}-ben elõforduló változó):

\begin{itemize}
	\item \cd{X} tartományának bármilyen változásakor
        \item \cd{dom(Y), card(Y)} környezetben elõforduló \cd{Y} változó esetén az
        indexikális a változó tartományának bármilyen módosulásakor
        aktiválandó; 
        \item \cd{min(Y)} környezetben -- alsó határ változásakor
        aktiválandó;
         \item
        \cd{max(Y)} környezetben -- felsõ határ változásakor aktiválandó.
\end{itemize}

Ha az indexikális felébred, két eset lehetséges:

\begin{itemize}
        \item Ha \domx{X} $\subseteq$ \setx{R}, akkor a korlát levezethetõvé vált.
        \item Ha  \domx{X} és \setx{R} diszjunktak, valamint
        \setx{R} monoton is (vagyis konstans, mivel idáig csak akkor juthattunk el,
	ha antimonoton is), akkor a korlát negáltja levezethetõvé vált (emiatt
        felesleges az \cd{'x\bs\bs=y'} FD predikátum 4. klóza).
	\item Egyébként újra elaltatjuk az indexikálist. 
\end{itemize}

Egy egyszerû példa:

\begin{alltt}
'x=<y'(X,Y) +?                 
        X in inf..min(Y).      {\em% (ind1)}
\end{alltt}

\enum{Az \cd{\em (ind1)} kérdezõ indexikális végrehajtási lépései}{
\item Végrehajthatóság vizsgálata: nincs benne pucér változó, minden tárban
antimonoton, tehát végrehajtható
\item Aktiválás: \cd{Y} alsó határának változásakor.
\item Levezethetõség: megvizsgáljuk, hogy \cd{X} tartománya része-e az
\cd{inf..min(Y)} tartománynak, azaz \cd{max(X) =< min(Y)} fennáll-e.  Ha
igen, akkor a korlát levezethetõvé vált, a démon befejezi mûködését, és a
reifikációs változó az \cd{1} értéket kapja.
\item Negált levezethetõsége: megvizsgáljuk, hogy a tartománykifejezés
konstans-e, azaz \cd{Y} behelyettesített-e. Ha igen, akkor megvizsgáljuk,
hogy az \cd{inf..min(Y)} intervallum és \cd{X} tartománya diszjunktak-e,
azaz \cd{Y~<~min(X)} fennáll-e. Ha mindez teljesült, akkor a korlát
negáltja levezethetõvé vált, a démon befejezi mûködését, és a reifikációs
változó a \cd{0} értéket kapja.
}

\subsubsection{Korlátok automatikus fordítása indexikálisokká}

A SICStus lehetõséget kínál arra, hogy egy egyszerû \clpfd korlátot
automatikusan indexikálissá fordítsunk. A következõ korlátozások érvényesek:

\begin{itemize}
\item Az indexikálissá fordítandó kifejezés formája \cd{Head} \cd{+:} \cd{Korlát.},
ahol \cd{Korlát} csak lineáris kifejezésekbõl álló \emph{aritmetikai}
korlát vagy a \cd{relation/3} és \cd{element/3} szimbolikus korlátok egyike
lehet. A \cd{relation/3} és \cd{element/3} korlátok unió- és kapcsoló-kifejezésekké
fordulnak (ld. \pageref{unio:ind}. oldal). Mivel ezek végrehajtási ideje erõsen függ
a tartomány méretétõl, ezért vigyázni kell a kezdõ tartományok megfelelõ beállítására.
\item Csak a \cd{+:} nyakjel használható, így ezek a korlátok nem reifikálhatóak.
\end{itemize}

Az így kapott átfordított korlátok a változók számának függvényében négyzetes
helyigényûek (szemben az eredeti korlátok lineáris helyigényével) és általában lassabbak
is. Elõfordulhat azonban olyan eset is, hogy az átfordított változat gyorsabb, mint
ahogy a késõbb ismertetésre kerülõ torpedó és dominó feladatok esetén is:

\br

\begin{center}\begin{tabular}{|l|r|r|c|l|r|r|}
\cline{1-3}\cline{5-7}
Torpedó        & \cd{:-} & \cd{+:} & \hspace{0.5cm} & Dominó & \cd{:-} & \cd{+:} \\
\cline{1-3}\cline{5-7}
fules2         & 12.31   & 10.67   & \hspace{0.5cm} &   2803 &   174.7 & 127.6 \\
dense-clean    &  4.02   &  2.77   & \hspace{0.5cm} &   2804 &    37.3 &  27.7 \\
dense-collapse &  1.79   &  1.29   & \hspace{0.5cm} &   2805 &   327.7 & 239.8 \\
\cline{1-3}\cline{5-7}
\end{tabular}\end{center}
\br

A torpedó feladatban a \cd{relation/3} korlátot, a dominó feladatban a
\cd{B1+...+BN \#= 1} alakú korlátokat (\cd{Bi 0..1} értékû változók, \cd{N=<5})
fejtettünk ki indexikálisokká.

\subsubsection{Indexikálisok összefoglalása}

Legyen \cd{C(Y$_1$, $\ldots$, Y$_n$)} egy FD-predikátum, amelyben szerepel egy
\begin{center}
  \cd{Y$_i$ in R(Y$_1$, $\ldots$, Y$_{i-1}$, Y$_{i+1}$, $\ldots$, Y$_n$)}
\end{center}
indexikális. Az \cd{R} tartománykifejezés által definiált reláció:

\[ C = \{ \tuple{y_1, \ldots, y_n} |  y_i \in S(\cd{R},\tuple{{\tt
Y}_1=y_1,
 \ldots, \cd{Y}_{i-1}=y_{i-1}, \cd{Y}_{i+1}=y_{i+1},  \ldots })\}\]

{\bf Kiterjesztett alapszabály}: Egy FD-predikátum csak akkor
értelmes, ha a pozitív (\cd{+:} és \cd{+?} nyakjelû) klózaiban levõ összes
indexikális ugyanazt a relációt definiálja, továbbá a negatív (\cd{-:} és
\cd{-?} nyakjelû) klózaiban levõ összes indexikális ennek a relációnak a
negáltját (komplemensét) definiálja.
\br
Ha $R$ monoton egy $s$ tárra nézve, akkor $S(R,s)$-rõl belátható,
hogy minden olyan $y_i$ értéket tartalmaz, amelyek (az $s$ által
megengedett $y_j$ értékekkel együtt) a $C$ relációt
kielégítik. Ezért szûkítõ indexikálisok esetén jogos az $Y_i$
tartományát $S(R,s)$-rel szûkíteni. Ha viszont $R$ antimonoton egy $s$ tárra
nézve, akkor $S(R,s)$-rõl belátható, hogy minden olyan $y_i$ értéket kizár,
amelyekre (az $s$ által megengedett legalább egy $y_j$ érték-rendszerrel együtt)
a $C$ reláció nem áll fenn. Ezért kérdezõ indexikálisok esetén, ha $D(Y_i,s)
\subseteq S(R,s)$, jogos a korlátot az $s$ tárból levezethetõnek
tekinteni. A fentiek miatt természetesen adódik az indexikálisok
felfüggesztési szabálya: a szûkítõ indexikálisok végrehajtását
mindaddig felfüggesztjük, amíg monotonná nem válnak; a kérdezõ
indexikálisok végrehajtását mindaddig felfüggesztjük, amíg
antimonotonná nem válnak.
\br
{\bf Az indexikálisok deklaratív volta:} Ha a fenti alapszabályt
betartjuk, akkor a \clpfd megvalósítás az FD-predikátumot helyesen
valósítja meg, azaz mire a változók teljesen behelyettesítetté
válnak, az FD predikátum akkor és csak akkor for sikeresen lefutni, vagy
az 1 értékre tükrözõdni (reifikálódni), ha a változók értékei a
predikátum által definiált relációhoz tartoznak. Az indexikális
megfogalmazásán csak az múlik, hogy a nem konstans tárak esetén milyen
jó lesz a szûkítõ, ill. kérdezõ viselkedése.
